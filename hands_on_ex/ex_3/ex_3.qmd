---
title: "Hand on ex 3 - Chap 5 Geographical Segmentation with Spatially Constrained Clustering Techniques"
editor: visual
---

# Overview

# Step 1: Loading the required packages

We load the required packages as follow:

```{r}
pacman::p_load(sf, rgdal, spdep,
               tidyverse,
               tmap,
               corrplot, ggpubr, heatmaply,
               cluster, 
               factoextra, NbClust, psych,
               here)
```

Next we generate the link to the file:

```{r}
shapefile_path <- here("data", "dataMyanmar", "geospatial")
shapefile_path
```

Now we load the shapefile:\
(question: why never set the CRS here ?)

```{r}
shan_sf <- st_read(dsn = shapefile_path, 
                   layer = "myanmar_township_boundaries") %>% 
           filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)"))
```

We check the CRS as follow:

```{r}
st_crs(shan_sf)
```

We also get a view of the data:

```{r}
glimpse(shan_sf)
```

# Step 2: Import Aspatial Data

Create the link:

```{r}
aspatial_path <- here("data", "dataMyanmar", "aspatial", "Shan-ICT.csv")
aspatial_path
```

Load the CSV file using read_csv() from readr package:

```{r}
ict <- read_csv (aspatial_path)
```

Note: the file is saved in the tibble file format. Which is different from sf format.

------------------------------------------------------------------------

Next we get the summary statistics:

```{r}
summary(ict)
```

# Step 3: Deriving new variables

We will use the mutate() function and %\>% to get new variables:

```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) 
```

We now check the summary of the new derived variables:

```{r}
summary(ict_derived)
```

# Step 4: EDA Part 1

We will make use of the ggplot for EDA.

We plot the histogram of the radio as follow:

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light pink")
```

We will next use the box plot to check for outliers:

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_boxplot(color="black", 
               fill="light pink")
```

Plot histogram of radio penetration rate:

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light pink")
```

We will check the outlier of the Radio Penetration as follow:

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_boxplot(color="black", 
               fill="light pink")
```

Next, we will create multiple plots first:

```{r}
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

Using the ggarange() of the ggpubr package, we can plot multiple graphs together:

```{r}
ggarrange(radio, tv, llphone, mphone, computer, internet, 
          ncol = 3, 
          nrow = 2)
```

# Step 5: EDA Part 2

Next we perform relational join using the function left_join().

We will join using the common column "TS_CODE":

```{r}
shan_sf <- left_join(shan_sf, 
                     ict_derived, 
                     by=c("TS_PCODE"="TS_PCODE"))
```

We will then do a quick plot of the radio penetration level with qtm() of the tmap package:

```{r}
qtm(shan_sf, "RADIO_PR")
```

Next using the "Jenks" classification, we will plot 2 maps. \
One for number of houses, the other for the number of radios:

```{r}
TT_HOUSEHOLDS.map <- tm_shape(shan_sf) + 
  tm_fill(col = "TT_HOUSEHOLDS",
          n = 5,
          style = "jenks", 
          title = "Total households") + 
  tm_borders(alpha = 0.5) 

RADIO.map <- tm_shape(shan_sf) + 
  tm_fill(col = "RADIO",
          n = 5,
          style = "jenks",
          title = "Number Radio ") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,
             asp=NA, ncol=2)
```

We will also look at the map with number of households vs radio penetration rate:

```{r}
tm_shape(shan_sf) +
    tm_polygons(c("TT_HOUSEHOLDS", "RADIO_PR"),
                style="jenks") +
    tm_facets(sync = TRUE, ncol = 2) +
  tm_legend(legend.position = c("right", "bottom"))+
  tm_layout(outer.margins=0, asp=0)
```

# Step 6: Correlation Analysis

Before performing cluster analysis, we need to remove variables that are highly correlated to each other.

We do this by using corrplot.mixed() of the corrplot:

```{r}
cluster_vars.cor = cor(ict_derived[,12:17])
corrplot.mixed(cluster_vars.cor,
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

Above we observe 2 highly correlated variables.

# Step 7: Hierarchy Cluster Analysis

## Prepare the data

We select the clustering variables now. Notice we use the st_set_geometry(NULL) to exclude the geometry column:

```{r}
cluster_vars <- shan_sf %>%
  st_set_geometry(NULL) %>%
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")
head(cluster_vars,10)
```

Next, we will change the names of the row:

```{r}
row.names(cluster_vars) <- cluster_vars$"TS.x"
head(cluster_vars,10)
```

Next we will delete the TS.x row:

```{r}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)
```

## Data Standardization

Since different variables are used, their range is different. Thus we need to standardize them.

### Min Max 

We do min-max 0-1 as follow:

```{r}
shan_ict.std <- normalize(shan_ict)
summary(shan_ict.std)
```

### Z-Score

Next, we perform Z-score standardization as follow:

```{r}
shan_ict.z <- scale(shan_ict)
describe(shan_ict.z)
```

After doing this step, the mean and std dev are now 0 and 1 respectively.

------------------------------------------------------------------------

### Visualize the standardized variables

Next we visualize the variables:

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

## Compute Proximity Matrix

We will use dist() of R to compute the proximity matrix:

```{r}
proxmat <- dist(shan_ict, method = 'euclidean')
```

## Compute Hierarchical Clustering

Using hclust() of R stats, we will input the proximity matrix. The putout is a class of hclust that describes a tree that is produced:

```{r}
hclust_ward <- hclust(proxmat, method = 'ward.D')
```

We can then plot the result as follow:

```{r}
plot(hclust_ward, cex = 0.6)
```
