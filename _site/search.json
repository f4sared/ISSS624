[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "hands_on_ex/ex_1/ex_1.html",
    "href": "hands_on_ex/ex_1/ex_1.html",
    "title": "Hand on ex 1 - Chap 1 Geodata wrangling",
    "section": "",
    "text": "Step 1: Load packages\n\npacman::p_load(sf,tidyverse)\n\n\n\nStep 2: Import Geo spatial Data\nImport shapefile into R as a polygon feature dataframe :\n\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `D:\\f4sared\\ISSS624\\hands_on_ex\\ex_1\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nImport shapefile into R as a line feature dataframe :\n\ncyclingpath <- st_read(dsn = \"data/geospatial\", layer = \"CyclingPath\")\n\nReading layer `CyclingPath' from data source \n  `D:\\f4sared\\ISSS624\\hands_on_ex\\ex_1\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 1625 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 12711.19 ymin: 28711.33 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\nImport KML into R as a Point format:\n\npreschool <- st_read(\"data/geospatial/pre-schools-location-kml.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `D:\\f4sared\\ISSS624\\hands_on_ex\\ex_1\\data\\geospatial\\pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1359 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\n\n\nStep 3: Check content of the data frame\nThis function provides a simple overview of the dataframe:\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\nThis function gives a detailed breakdown of the columns and the data within the column:\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\nHere we will take a detailed look at the first 5 rows of the dataset:\n\nhead(mpsz, n=5)\n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n\n\n\n\nStep 4: Plotting the data\nBelow command will plot a map for each of the columns:\n\nplot(mpsz)\n\nWarning: plotting the first 9 out of 15 attributes; use max.plot = 15 to plot\nall\n\n\n\n\n\nIn order to plot the whole map only, we use the following:\n\nplot(st_geometry(mpsz))\n\n\n\n\nAlso we can choose to plot based on a specific column or “feature”:\n\nplot(mpsz[\"PLN_AREA_N\"])\n\n\n\n\nNote***\nplot() is only meant for a quick look, for cartographic quality, we should use other packages such as tamp.\n\n\nStep 5: Working with projections\nProjection is important because we want to use geospatial data that are of similar coordinate system.\nThe following code will show how to project from one coordinate system to another coordinate system.\nCheck the coordinate reference system as follow:\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nNote***\nEPSG stands for “European Petroleum Survey Group”\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\n\nQuestion to self: Why is there a warning above ?\nBelow we will set the correct EPSG code to 3414:\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\nNext we will convert the projection of preschool from wsg84 to svy21:\nWe will take a loot at the CRS o the preschool:\n\nst_crs(preschool)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n\nNow we will convert:\n\npreschool3414 <- st_transform(preschool, crs=3414)\n\nWe will now take a look at the converted geometry dataframe:\n\nst_geometry(preschool3414)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11203.01 ymin: 25667.6 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nPOINT Z (19997.26 32333.17 0)\n\n\nPOINT Z (19126.75 33114.35 0)\n\n\nPOINT Z (20345.12 31934.56 0)\n\n\nPOINT Z (20400.31 31952.36 0)\n\n\nPOINT Z (19810.78 33140.31 0)\n\n\nWe can see that after conversion, the values of the geometry are now different:\n\nglimpse(preschool)\n\nRows: 1,359\nColumns: 3\n$ Name        <chr> \"kml_1\", \"kml_2\", \"kml_3\", \"kml_4\", \"kml_5\", \"kml_6\", \"kml…\n$ Description <chr> \"<center><table><tr><th colspan='2' align='center'><em>Att…\n$ geometry    <POINT [°]> POINT Z (103.7614 1.308683 0), POINT Z (103.7536 1.3…\n\n\n\nglimpse(preschool3414)\n\nRows: 1,359\nColumns: 3\n$ Name        <chr> \"kml_1\", \"kml_2\", \"kml_3\", \"kml_4\", \"kml_5\", \"kml_6\", \"kml…\n$ Description <chr> \"<center><table><tr><th colspan='2' align='center'><em>Att…\n$ geometry    <POINT [m]> POINT Z (19997.26 32333.17 0), POINT Z (19126.75 331…\n\n\nJust for interest, we will plot the preschool data:\n\nplot(preschool3414)\n\n\n\n\n\n\nStep 6: Importing and Converting Aspatial Data\nWe first import the csv file:\n\nlistings <- read_csv(\"data/aspatial/listings.csv\")\n\nRows: 4252 Columns: 16\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr   (5): name, host_name, neighbourhood_group, neighbourhood, room_type\ndbl  (10): id, host_id, latitude, longitude, price, minimum_nights, number_o...\ndate  (1): last_review\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nNext, we check if the files has been imported correctly:\n**Here, we will assume that the coordinate data is in the degree format & in wgs84 system\n**WGS stands for “World Geodetic System”\n\nlist(listings)\n\n[[1]]\n# A tibble: 4,252 × 16\n       id name     host_id host_…¹ neigh…² neigh…³ latit…⁴ longi…⁵ room_…⁶ price\n    <dbl> <chr>      <dbl> <chr>   <chr>   <chr>     <dbl>   <dbl> <chr>   <dbl>\n 1  50646 Pleasan…  227796 Sujatha Centra… Bukit …    1.33    104. Privat…    80\n 2  71609 Ensuite…  367042 Belinda East R… Tampin…    1.35    104. Privat…   178\n 3  71896 B&B  Ro…  367042 Belinda East R… Tampin…    1.35    104. Privat…    81\n 4  71903 Room 2-…  367042 Belinda East R… Tampin…    1.35    104. Privat…    81\n 5 275343 Conveni… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    52\n 6 275344 15 mins… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    40\n 7 294281 5 mins … 1521514 Elizab… Centra… Newton     1.31    104. Privat…    72\n 8 301247 Nice ro… 1552002 Rahul   Centra… Geylang    1.32    104. Privat…    41\n 9 324945 20 Mins… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    49\n10 330089 Accomo@… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    49\n# … with 4,242 more rows, 6 more variables: minimum_nights <dbl>,\n#   number_of_reviews <dbl>, last_review <date>, reviews_per_month <dbl>,\n#   calculated_host_listings_count <dbl>, availability_365 <dbl>, and\n#   abbreviated variable names ¹​host_name, ²​neighbourhood_group,\n#   ³​neighbourhood, ⁴​latitude, ⁵​longitude, ⁶​room_type\n\n\nNext, we will convert the imported csv file to a dataframe:\nWe will first convert listings into a dataframe, then convert/project accordingly.\n\nlistings_sf <- st_as_sf(listings, coords = c(\"longitude\",\"latitude\"), crs=4326) %>% st_transform(crs=3414)\n\nNext we will take a look at the features and columns:\n\nglimpse(listings_sf)\n\nRows: 4,252\nColumns: 15\n$ id                             <dbl> 50646, 71609, 71896, 71903, 275343, 275…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <dbl> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <dbl> 80, 178, 81, 81, 52, 40, 72, 41, 49, 49…\n$ minimum_nights                 <dbl> 90, 90, 90, 90, 14, 14, 90, 8, 14, 14, …\n$ number_of_reviews              <dbl> 18, 20, 24, 48, 20, 13, 133, 105, 14, 1…\n$ last_review                    <date> 2014-07-08, 2019-12-28, 2014-12-10, 20…\n$ reviews_per_month              <dbl> 0.22, 0.28, 0.33, 0.67, 0.20, 0.16, 1.2…\n$ calculated_host_listings_count <dbl> 1, 4, 4, 4, 50, 50, 7, 1, 50, 50, 50, 4…\n$ availability_365               <dbl> 365, 365, 365, 365, 353, 364, 365, 90, …\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…\n\n\n\n\nStep 7: Geoprocessing with sf package\nIn this section, we will learn to use geo processing functions, buffering and point in polygon count.\n\nBuffering\n\nbuffer_cycling <- st_buffer(cyclingpath, dist = 5, nQuadSegs = 30)\n\nJust for interest, we will plot the buffered cycling path:\n\nplot(buffer_cycling)\n\n\n\n\nNext we calculate the area:\nWe will add this back to the main dataframe buffer_cycling\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\nNext, we will get the sum:\n\nsum(buffer_cycling$AREA)\n\n773143.9 [m^2]\n\n\nWe will also take a look at the newly added column “AREA”\n\nglimpse(buffer_cycling)\n\nRows: 1,625\nColumns: 4\n$ CYL_PATH_C <chr> \"SBWG\", \"SBWG\", \"SBWG\", \"SBWG\", \"SBWG\", \"SBWG\", \"SBWG\", \"SB…\n$ CYL_PATH_1 <chr> \"Sembawang\", \"Sembawang\", \"Sembawang\", \"Sembawang\", \"Sembaw…\n$ geometry   <POLYGON [m]> POLYGON ((26829 47350.2, 26..., POLYGON ((26762.25 …\n$ AREA       [m^2] 547.08438 [m^2], 681.87931 [m^2], 432.75754 [m^2], 404.6815…\n\n\n\n\nPoint in polygon count\nWe first check the dataframe:\nOur dataframe consists of 323 areas\n\nmpsz\n\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29...\n\n\nPerform first intersection:\nThis will produce a dataframe with 323 rows. In each of the rows, we will get the index of the preschool whose coordinates fall into our polygon area.\n\nintersect <- st_intersects(mpsz3414, preschool3414)\n\nStore the counts into the main dataframe\n\nmpsz3414$`PreSch Count`<- lengths(intersect)\n\nCheck the summary statistics:\n\nsummary(mpsz3414$`PreSch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.000   4.207   6.000  37.000 \n\n\nNext, we will list the top 3 planning zone with most number of preschools using the function below:\n\ntop_n(mpsz3414, 3, `PreSch Count`)\n\nSimple feature collection with 3 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 23449.05 ymin: 35966 xmax: 42940.57 ymax: 47996.47\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO            SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N\n1      189          2        TAMPINES EAST    TMSZ02      N   TAMPINES\n2      272          3 SENGKANG TOWN CENTRE    SESZ03      N   SENGKANG\n3      290          3       WOODLANDS EAST    WDSZ03      N  WOODLANDS\n  PLN_AREA_C          REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         TM       EAST REGION       ER 21658EAAF84F4D8D 2014-12-05 41122.55\n2         SE NORTH-EAST REGION      NER 5A2D0E9E6B285069 2014-12-05 35163.81\n3         WD      NORTH REGION       NR C90769E43EE6B0F2 2014-12-05 24506.64\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry PreSch Count\n1 37392.39  10180.624    4339824 MULTIPOLYGON (((42196.76 38...           33\n2 41501.14   5216.401    1455508 MULTIPOLYGON (((35615.75 40...           25\n3 46991.63   6603.608    2553464 MULTIPOLYGON (((24786.75 46...           37\n\n\nCalculate and save the area:\n\nmpsz3414$Area <- mpsz3414 %>% st_area()\n\n\ntesting <- mpsz3414 %>% st_area()\nhead(testing, n=20)\n\nUnits: [m^2]\n [1]  1630379.3   559816.2   160807.5   595428.9   387429.4  1030378.8\n [7]   551732.0   290184.7  1084792.3   631644.3  1826848.6   293706.4\n[13]  1844060.7   392563.3   506589.0 36707720.9  4207271.1  4963787.1\n[19]  2206319.5  4919132.4\n\n\nUse the mutate function:\n\nmpsz3414 <- mpsz3414 %>% mutate(`PreSch Density` = (`PreSch Count`/Area)*1000000)\n\n\nFor fun and learning, we will try to plot a specific area such as queens town\n\nspecific_plot <- mpsz3414 %>% filter(PLN_AREA_C == \"MS\")\nplot(specific_plot[\"PLN_AREA_N\"])\n\n\n\nplot(st_geometry(specific_plot))\n\n\n\n\n\n\n\n\nStep 8: EDA Exploratory Data Analysis\nCreate a histogram to show the preschool density:\n\nhist(mpsz3414$`PreSch Density`)\n\n\n\n\nTo get better plot, we will use ggplot:\n\nggplot(data=mpsz3414, \n       aes(x= as.numeric(`PreSch Density`)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(title = \"Are pre-school even distributed in Singapore?\",\n       subtitle= \"There are many planning sub-zones with a single pre-school, on the other hand, \\nthere are two planning sub-zones with at least 20 pre-schools\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Frequency\")\n\n\n\n\n\nggplot(data=mpsz3414, \n       aes(x= as.numeric(`PreSch Density`), y= as.numeric(`PreSch Count`)))+ geom_point()+\n    labs(title = \"Scatter Plot\",\n       subtitle= \"My Plot\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Preschool Counts\")\n\n\n\n\n```"
  },
  {
    "objectID": "hands_on_ex/ex_1/ex_1_2.html#step-1-import-packages",
    "href": "hands_on_ex/ex_1/ex_1_2.html#step-1-import-packages",
    "title": "Hand on ex 1 - Chap 2 Choropleth Mapping with R",
    "section": "Step 1: Import Packages",
    "text": "Step 1: Import Packages\nAs usual, we first import all the packages:\n\npacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "hands_on_ex/ex_1/ex_1_2.html#step-2-import-the-data",
    "href": "hands_on_ex/ex_1/ex_1_2.html#step-2-import-the-data",
    "title": "Hand on ex 1 - Chap 2 Choropleth Mapping with R",
    "section": "Step 2: Import the data",
    "text": "Step 2: Import the data\n\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `D:\\f4sared\\ISSS624\\hands_on_ex\\ex_1\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nExamine the contents:\n\nhead(mpsz, n=1)\n\nSimple feature collection with 1 feature and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 30794.28 ymin: 28369.47 xmax: 32362.39 ymax: 30140.01\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO    SUBZONE_N SUBZONE_C CA_IND   PLN_AREA_N PLN_AREA_C\n1        1          1 MARINA SOUTH    MSSZ01      Y MARINA SOUTH         MS\n        REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR\n1 CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84 29220.19\n  SHAPE_Leng SHAPE_Area                       geometry\n1   5267.381    1630379 MULTIPOLYGON (((31495.56 30...\n\n\nNext, we import the csv attribute data into R:\n\npopdata <- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")\n\nRows: 984656 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, TOD\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nData Wrangling:\nBelow we will prepare the new dataframe.\n\npopdata2020 <- popdata %>%\n  filter(Time == 2020) %>%\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP` = sum(`Pop`)) %>%\n  ungroup()%>%\n  pivot_wider(names_from=AG, \n              values_from=POP) %>%\n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %>%\nmutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+\nrowSums(.[13:15]))%>%\nmutate(`AGED`=rowSums(.[16:21])) %>%\nmutate(`TOTAL`=rowSums(.[3:21])) %>%  \nmutate(`DEPENDENCY` = (`YOUNG` + `AGED`)\n/`ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, \n       `ECONOMY ACTIVE`, `AGED`, \n       `TOTAL`, `DEPENDENCY`)\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n\n\nConvert some data into upper case:\n\npopdata2020 <- popdata2020 %>%\n  mutate_at(.vars = vars(PA, SZ), \n          .funs = funs(toupper)) %>%\n  filter(`ECONOMY ACTIVE` > 0)\n\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nℹ Please use a list of either functions or lambdas:\n\n# Simple named list: list(mean = mean, median = median)\n\n# Auto named with `tibble::lst()`: tibble::lst(mean, median)\n\n# Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\n\n\nNext we will join the tables together:\n\nmpsz_pop2020 <- left_join(mpsz, popdata2020, by = c(\"SUBZONE_N\" = \"SZ\"))\n\nSave the table:\n\nwrite_rds(mpsz_pop2020, \"data/rds/mpszpop2020.rds\")"
  },
  {
    "objectID": "hands_on_ex/ex_1/ex_1_2.html#step-3-plotting-with-various-tools",
    "href": "hands_on_ex/ex_1/ex_1_2.html#step-3-plotting-with-various-tools",
    "title": "Hand on ex 1 - Chap 2 Choropleth Mapping with R",
    "section": "Step 3: Plotting with various tools",
    "text": "Step 3: Plotting with various tools\n\nUsing qtm()\nMake our first plot based on the column “Dependency”.\nHowever, a disadvantage of qtm() is that i makes individual layers harder to control.\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\nqtm(mpsz_pop2020, fill = \"DEPENDENCY\")\n\n\n\n\n\n\nUsing tm_shape()\nWith the disadvantage of the qtm(), we will next try tm_shape() to get better professional quality:\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\nDrawing a base map\nUisng tm_shape() as the basic building block.\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\nWe can also draw according to each column feature with tm_polygon:\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\")\n\n\n\n\ntm_polygon is a wrapper of tm_fill, just that it is missing the borders:\n\ntm_shape(mpsz_pop2020)+tm_fill(\"DEPENDENCY\")\n\n\n\n\nso now, we will add the borders in:\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(lwd = 0.1,  alpha = 1)\n\n\n\n\n\n\nData Classification Methods: Using Different Styles\nNote: tmap has a total of ten data classification methods !\nHere we will use classification quantile of 5 classes:\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nAnother option is to make each bin range equal as follow:\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\nDIY_1: Here we try out some different styles:\n\nA <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"DEPENDENCY\", \n              style = \"jenks\", \n              palette = \"Blues\")+\n    tm_layout(main.title = \"jenks\")\n\nB <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"DEPENDENCY\", \n              style = \"quantile\", \n              palette = \"Blues\")+\n  tm_layout(main.title = \"quantile\")\n\nC <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"DEPENDENCY\", \n              style = \"sd\", \n              palette = \"Blues\")+\n  tm_layout(main.title = \"sd\")\n\nD <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"DEPENDENCY\", \n              style = \"equal\", \n              palette = \"Blues\")+\n  tm_layout(main.title = \"equal\")\n\ntmap_arrange(A, B, C, D, asp=2, ncol=2)\n\n\n\n\nThe three basic methods are quantile, sd (standard deviation) and equal. One of the most informative plot would be the “quantile” classification style. As shown above, this styles provides the most distinct visual classification that is more informative.\nThe “equal” style provides the least information since each bin is separated into equal range.\nUsing the style “quantile” allows us to take into account the distribution of the data.\nAs shown below, majority of the values are below 5.\n\nggplot(data=mpsz_pop2020, \n       aes(x= as.numeric(`DEPENDENCY`)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(title = \"Distribution of DEPENDENCY\",\n      x = \"DEPENDENCY\",\n      y = \"Frequency\")\n\nWarning: Removed 92 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\n\nDIY_2: Data Classification Methods: Using different number of classes\nFor this section, we will use jenks !\nwhere n = 2, 6, 10 , 20\n\nA <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"DEPENDENCY\", \n              n=2,\n              style = \"jenks\", \n              palette = \"Blues\")+\n    tm_layout(main.title = \"n=2\")\n\nB <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"DEPENDENCY\", \n              n=6,\n              style = \"jenks\", \n              palette = \"Blues\")+\n  tm_layout(main.title = \"n=6\")\n\nC <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"DEPENDENCY\", \n              n=10,\n              style = \"jenks\", \n              palette = \"Blues\")+\n  tm_layout(main.title = \"n=10\")\n\nD <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"DEPENDENCY\", \n              n=20,\n              style = \"jenks\", \n              palette = \"Blues\")+\n  tm_layout(main.title = \"n=20\")\n\ntmap_arrange(A, B, C, D, asp=2, ncol=2)\n\n\n\n\nFrom what we can see above, as the number of classes get bigger and bigger, more and more details are revealed ! Previous regions with similar colors are now further differentiated with better gradient spread."
  },
  {
    "objectID": "hands_on_ex/ex_1/ex_1_2.html#step-4-color-scheme",
    "href": "hands_on_ex/ex_1/ex_1_2.html#step-4-color-scheme",
    "title": "Hand on ex 1 - Chap 2 Choropleth Mapping with R",
    "section": "Step 4: Color scheme",
    "text": "Step 4: Color scheme\nHere, we will assign a new color !\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nWe can also reverse the color shading as follow:\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)"
  },
  {
    "objectID": "hands_on_ex/ex_1/ex_1_2.html#step-5-map-layouts-and-styles",
    "href": "hands_on_ex/ex_1/ex_1_2.html#step-5-map-layouts-and-styles",
    "title": "Hand on ex 1 - Chap 2 Choropleth Mapping with R",
    "section": "Step 5: Map Layouts and styles",
    "text": "Step 5: Map Layouts and styles\nApparently we can add even more customization options to our map plots !\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\nWe can even change the map style and appearance !\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n\ntmap style set to \"classic\"\n\n\nother available styles are: \"white\", \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"watercolor\""
  },
  {
    "objectID": "hands_on_ex/ex_1/ex_1_2.html#step-6-add-cartographic-furniture-to-the-map",
    "href": "hands_on_ex/ex_1/ex_1_2.html#step-6-add-cartographic-furniture-to-the-map",
    "title": "Hand on ex 1 - Chap 2 Choropleth Mapping with R",
    "section": "Step 6: Add Cartographic Furniture to the map",
    "text": "Step 6: Add Cartographic Furniture to the map\nWe can further add more useful features to the generated map\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))"
  },
  {
    "objectID": "hands_on_ex/ex_1/ex_1_2.html#step-7-multiple-map",
    "href": "hands_on_ex/ex_1/ex_1_2.html#step-7-multiple-map",
    "title": "Hand on ex 1 - Chap 2 Choropleth Mapping with R",
    "section": "Step 7: Multiple map",
    "text": "Step 7: Multiple map\nHere we will attempt to plot multiple plots together:\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\nWe can even mix and match 2 different maps with different styles and fearures\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n\n\n\n\nWe can further make facet plots of different regions:\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE, \n            drop.shapes=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\nWarning: The argument drop.shapes has been renamed to drop.units, and is\ntherefore deprecated\n\n\n\n\n\nCreate multiple standalone maps:\n\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\nSelect areas that meets criterion:\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend"
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#minor-notes",
    "href": "hands_on_ex/ex_2/ex_2.html#minor-notes",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Minor notes:",
    "text": "Minor notes:\nUseful Links:\n\nhttps://bookdown.org/nicohahn/making_maps_with_r5/docs/tmap.html\nhttps://www.rdocumentation.org/packages/classInt/versions/0.4-8/topics/classIntervals\n\nstyle = pretty: Rounds interval boundaries to whole numbers. Default setting.\nstyle = equal: Splits the variable into intervals of equal length. Should only be used if the variable follows an uniform distribution.\nstyle = quantile: Splits the variable into quantiles. Consequently there are the same number of observations in each interval.\nstyle = jenks: Identifies groups with similar values and maximizes the difference between them.\nstyle = cont: Displays many colors over a continuous palette.\nstyle = cat: Colors each category individually for categorical data."
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#morans-i-test",
    "href": "hands_on_ex/ex_2/ex_2.html#morans-i-test",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Moran’s I Test:",
    "text": "Moran’s I Test:\n**moran.test() belongs to spdep\n**Are we testing against randomization or normality ?\n\nmoran.test(hunan$GDPPC, listw=rswm_q, zero.policy = TRUE, na.action = na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n\n\nUseful Link:\n\nhttps://bookdown.org/lexcomber/brunsdoncomber2e/morans-i-an-index-of-autocorrelation.html >> Moran’ I eigen value code\nhttps://www.youtube.com/watch?v=_FtR878eic4 >> Moran’s I explained\nhttps://www.youtube.com/watch?v=MPcNT0KUym0 >> Moran’s I ranging with eigen values\n\nWhen Moran’s I is 0, it means the points are distributed randomly across the space.\nWhen Moran’s I is 1, it means that similar values tend to cluster.\nOur P-value is 0.000001, which is really significant.\nWe calculate the Moran’s I eigen value range:\n**Note: The Moran’s I range is dependent on the inputs !\n\nmoran.range <- function(lw) {\n  wmat <- listw2mat(lw)\n  return(range(eigen((wmat + t(wmat))/2)$values))\n}\nmoran.range(rswm_q)\n\n[1] -0.733384  1.032489\n\n\nOur Moran’s estimate is 0.300 which is closer to 1.032 than -0.733."
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#monte-carlo-morans-i",
    "href": "hands_on_ex/ex_2/ex_2.html#monte-carlo-morans-i",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Monte Carlo Moran’s I:",
    "text": "Monte Carlo Moran’s I:\n\nset.seed(1234)\nbperm <- moran.mc(hunan$GDPPC, listw = rswm_q, nsim = 999, zero.policy = TRUE, na.action = na.omit)\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nHere we observe a similar Moran’s I value above.\nHowever, the p-value is now less significant as compared to the first test.\n\nPlot the Monte Carlo Moran’s I:\n**Why Monte Carlo ?\n**Monte Carlo is a statistical method that generates multiple datasets using random sampling.\n\nmean(bperm$res[1:999])\n\n[1] -0.01504572\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.004371574\n\n\n\nsummary(bperm$res[1:999])\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n\n\n\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\") \n\n\n\n\nPlot using ggplot:\nUseful Links:\n\nhttps://sparkbyexamples.com/r-programming/convert-list-to-r-dataframe/\nhttps://www.projectpro.io/recipes/change-column-headers-of-dataframe-r#:~:text=How%20to%20change%20column%20headers%20of%20a%20data%2Dframe%20in,can%20be%20changed%20at%20once.\n\nCreate a dataframe:\n\nxx <- data.frame(bperm$res)\n\n\ncolnames(xx)[1]  <- \"res\" \n\nPlot using ggplot:\n\nggplot(data=xx, aes(x= as.numeric(`res`)))+\n    geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n    labs(title = \"Distribution of DEPENDENCY\",\n      x = \"Moran's I\",\n      y = \"Frequency\")"
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#gearys-c-test",
    "href": "hands_on_ex/ex_2/ex_2.html#gearys-c-test",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Geary’s C test:",
    "text": "Geary’s C test:\n\ngeary.test(hunan$GDPPC, listw = rswm_q)\n\n\n    Geary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n\n\nHere we see a small p-value of 0.0001 which makes it statistically significant.\nFor Geary’s C, 1 means pure randomization. < 1 means clustering. > 1 means dispersed.\nOur value is 0.69, which tends towards some clustering."
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#monte-carlo-gearys-c",
    "href": "hands_on_ex/ex_2/ex_2.html#monte-carlo-gearys-c",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Monte Carlo Geary’s C:",
    "text": "Monte Carlo Geary’s C:\n\nset.seed(1234)\nbperm=geary.mc(hunan$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm\n\n\n    Monte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n\n\nHere, we see a higher P-Value which is less statistically significant.\nThe statistic value remains to be similar.\n\nPlot the Monte Carlo:\n\nmean(bperm$res[1:999])\n\n[1] 1.004402\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.007436493\n\n\n\nsummary(bperm$res[1:999])\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7142  0.9502  1.0052  1.0044  1.0595  1.2722 \n\n\n\nhist(bperm$res, freq=TRUE, breaks=20, xlab=\"Simulated Geary c\")\nabline(v=1, col=\"red\")"
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#morans-i",
    "href": "hands_on_ex/ex_2/ex_2.html#morans-i",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Moran’s I",
    "text": "Moran’s I\n\nMI_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr)\n\n\n\n\n\nprint(MI_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nAs we increase the order of lag, the Moran’s I value decreases. From a lag value of 3 onwards, we observe less indication of clustering."
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#gearys-c",
    "href": "hands_on_ex/ex_2/ex_2.html#gearys-c",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Geary’s C",
    "text": "Geary’s C\n\nGC_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"C\", \n                          style=\"W\")\nplot(GC_corr)\n\n\n\n\n\nprint(GC_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nAs we increase the lag, the C value increases, which shows less clustering. From a lag of 3 onwards, we observe less clustering."
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#plot-morans-scatterplot",
    "href": "hands_on_ex/ex_2/ex_2.html#plot-morans-scatterplot",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Plot Moran’s scatterplot:",
    "text": "Plot Moran’s scatterplot:\nUseful link:\n\nhttps://www.youtube.com/watch?v=G_l0xkuQUSs\n\nMoran’s plot is interesting because it plots the variable under study as the X-Axis, while the lagged variable will be plotted as the Y-Axis. The lagged variable in our cases is the average value of the neighbor surrounding our individual polygon. If the average neighbor value is close to the own value, the point will then fall on a straight line. The straight line is our Moran’s I.\nTake note that the top left quadrant and the bottom right signals to us that the variable of a polygon is not similar to the values the neighbor.\n\nnci <- moran.plot(hunan$GDPPC, rswm_q,\n                  labels=as.character(hunan$County), \n                  xlab=\"GDPPC 2012\", \n                  ylab=\"Spatially Lag GDPPC 2012\")"
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#plot-morans-scatterplot-with-standardized-variable",
    "href": "hands_on_ex/ex_2/ex_2.html#plot-morans-scatterplot-with-standardized-variable",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Plot Moran’s scatterplot with standardized variable:",
    "text": "Plot Moran’s scatterplot with standardized variable:\nWhy do we need to do this ? What is the use ?\n\nhunan$Z.GDPPC <- scale(hunan$GDPPC) %>% as.vector \n\n\nnci2 <- moran.plot(hunan$Z.GDPPC, rswm_q,\n                   labels=as.character(hunan$County),\n                   xlab=\"z-GDPPC 2012\", \n                   ylab=\"Spatially Lag z-GDPPC 2012\")"
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#preparing-lisa-map-classes",
    "href": "hands_on_ex/ex_2/ex_2.html#preparing-lisa-map-classes",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Preparing LISA map classes:",
    "text": "Preparing LISA map classes:\nWe create a empty vector based on the number of rows in the localMI:\n\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI))\n\nCenter the variable of interest around the mean:\n\nDV <- hunan$GDPPC - mean(hunan$GDPPC)  \n\nCenter the local Moran’s I around the mean:\n\nC_mI <- localMI[,1] - mean(localMI[,1])    \n\nSet the statistical significance level for the local Moran:\n\nsignif <- 0.05       \n\nPerform the first filter:\n**Note the order here is questionable, need to clarify further\n\nquadrant[DV >0 & C_mI>0] <- 4      \nquadrant[DV <0 & C_mI<0] <- 1      \nquadrant[DV <0 & C_mI>0] <- 2\nquadrant[DV >0 & C_mI<0] <- 3\n\nPlace non-significant Moran in category 0:\n\nquadrant[localMI[,5]>signif] <- 0"
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#plotting-the-lisa-map",
    "href": "hands_on_ex/ex_2/ex_2.html#plotting-the-lisa-map",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Plotting the LISA Map:",
    "text": "Plotting the LISA Map:\nInterpreting the LISA Map:\n\nhttps://www.e-education.psu.edu/geog586/node/673\n\n\nhunan.localMI$quadrant <- quadrant\ncolors <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5)"
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#deriving-spatial-weight-matrix",
    "href": "hands_on_ex/ex_2/ex_2.html#deriving-spatial-weight-matrix",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Deriving Spatial Weight Matrix",
    "text": "Deriving Spatial Weight Matrix\n\nDistance Based Matrix\nGet Centroid:\nValue 1:\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\nValue 2:\n\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nBind the coordinate into 1 object:\n\ncoords <- cbind(longitude, latitude)\n\nDetermine the cutoff distance using the k nearest neighbors:\n\n#coords <- coordinates(hunan)\nk1 <- knn2nb(knearneigh(coords))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nCompute the fixed distance weight matrix:\n\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\nConvert into spatial weights object\n\nwm62_lw <- nb2listw(wm_d62, style = 'B')\nsummary(wm62_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \nLink number distribution:\n\n 1  2  3  4  5  6 \n 6 15 14 26 20  7 \n6 least connected regions:\n6 15 30 32 56 65 with 1 link\n7 most connected regions:\n21 28 35 45 50 52 82 with 6 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1   S2\nB 88 7744 324 648 5440\n\n\n\n\nAdaptive distance weight Matrix\nHere we will enforce the condition that the number of neighbor for each polygon has to be 8:\n\nknn <- knn2nb(knearneigh(coords, k=8))\nknn\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\n\nConvert to spatial weight object:\n\nknn_lw <- nb2listw(knn, style = 'B')\nsummary(knn_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\nLink number distribution:\n\n 8 \n88 \n88 least connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n88 most connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 704 1300 23014"
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#computing-gi-statistics",
    "href": "hands_on_ex/ex_2/ex_2.html#computing-gi-statistics",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Computing Gi Statistics",
    "text": "Computing Gi Statistics\n\nUsing Fixed Distance\n\nfips <- order(hunan$County)\ngi.fixed <- localG(hunan$GDPPC, wm62_lw)\ngi.fixed\n\n [1]  0.436075843 -0.265505650 -0.073033665  0.413017033  0.273070579\n [6] -0.377510776  2.863898821  2.794350420  5.216125401  0.228236603\n[11]  0.951035346 -0.536334231  0.176761556  1.195564020 -0.033020610\n[16]  1.378081093 -0.585756761 -0.419680565  0.258805141  0.012056111\n[21] -0.145716531 -0.027158687 -0.318615290 -0.748946051 -0.961700582\n[26] -0.796851342 -1.033949773 -0.460979158 -0.885240161 -0.266671512\n[31] -0.886168613 -0.855476971 -0.922143185 -1.162328599  0.735582222\n[36] -0.003358489 -0.967459309 -1.259299080 -1.452256513 -1.540671121\n[41] -1.395011407 -1.681505286 -1.314110709 -0.767944457 -0.192889342\n[46]  2.720804542  1.809191360 -1.218469473 -0.511984469 -0.834546363\n[51] -0.908179070 -1.541081516 -1.192199867 -1.075080164 -1.631075961\n[56] -0.743472246  0.418842387  0.832943753 -0.710289083 -0.449718820\n[61] -0.493238743 -1.083386776  0.042979051  0.008596093  0.136337469\n[66]  2.203411744  2.690329952  4.453703219 -0.340842743 -0.129318589\n[71]  0.737806634 -1.246912658  0.666667559  1.088613505 -0.985792573\n[76]  1.233609606 -0.487196415  1.626174042 -1.060416797  0.425361422\n[81] -0.837897118 -0.314565243  0.371456331  4.424392623 -0.109566928\n[86]  1.364597995 -1.029658605 -0.718000620\nattr(,\"cluster\")\n [1] Low  Low  High High High High High High High Low  Low  High Low  Low  Low \n[16] High High High High Low  High High Low  Low  High Low  Low  Low  Low  Low \n[31] Low  Low  Low  High Low  Low  Low  Low  Low  Low  High Low  Low  Low  Low \n[46] High High Low  Low  Low  Low  High Low  Low  Low  Low  Low  High Low  Low \n[61] Low  Low  Low  High High High Low  High Low  Low  High Low  High High Low \n[76] High Low  Low  Low  Low  Low  Low  High High Low  High Low  Low \nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = hunan$GDPPC, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n\n\nJoin the data to dataframe:\n\nhunan.gi <- cbind(hunan, as.matrix(gi.fixed)) %>%\n  rename(gstat_fixed = as.matrix.gi.fixed.)\n\n\ngdppc <- qtm(hunan, \"GDPPC\")\n\nGimap <-tm_shape(hunan.gi) +\n  tm_fill(col = \"gstat_fixed\", \n          style = \"pretty\",\n          palette=\"-RdBu\",\n          title = \"local Gi\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(gdppc, Gimap, asp=1, ncol=2)\n\nVariable(s) \"gstat_fixed\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\nWe observe high level of significance of spatial concentration in the most central area highlighted by the red zone. However, we observe a steep change in the significance gradient of the local Gi score.\n\n\nUsing adaptive distance:\nCompute using adaptive weights:\n\nfips <- order(hunan$County)\ngi.adaptive <- localG(hunan$GDPPC, knn_lw)\nhunan.gi <- cbind(hunan, as.matrix(gi.adaptive)) %>%\n  rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n\ngdppc<- qtm(hunan, \"GDPPC\")\n\nGimap <- tm_shape(hunan.gi) + \n  tm_fill(col = \"gstat_adaptive\", \n          style = \"pretty\", \n          palette=\"-RdBu\", \n          title = \"local Gi\") + \n  tm_borders(alpha = 0.5)\n\ntmap_arrange(gdppc, \n             Gimap, \n             asp=1, \n             ncol=2)\n\nVariable(s) \"gstat_adaptive\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\nAgain, we observe a high level of spatial concentration significance in the areas highlighted in red. However, this time, we get a larger patch and a more gentle gradient distribution."
  },
  {
    "objectID": "hands_on_ex/ex_2/ex_2.html#thoughts",
    "href": "hands_on_ex/ex_2/ex_2.html#thoughts",
    "title": "Hand on ex 2 - Chap 4 Global and Local Measures of Spatial Autocorrelation",
    "section": "Thoughts:",
    "text": "Thoughts:\nSo apparently using different measures of distance weight matrix can have quite a big effect on the interpretation of the hotspot analysis. The question then lies in the motivation for selecting the different kinds of spatial weight matrix since they can produce different results."
  },
  {
    "objectID": "Hands_on_ex1.html",
    "href": "Hands_on_ex1.html",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "Hello ! Here is my second page"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS624_Licheng_Yan_Learning_Journal",
    "section": "",
    "text": "This Netlify site is a documentation of my learning journey for geospatial analytics and Rstudio\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n50 + 50\n\n[1] 100"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#queen",
    "href": "in_class/ex_1/in_class_ex_1.html#queen",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Queen:",
    "text": "Queen:\nCompute the (QUEEN) contiguity based neighbors weight matrix:\n\nwm_q <- poly2nb(hunan, queen = TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\nNext we want to see the neighbor for the first polygon:\n**Note: Both syntax below seem to work\n\nwm_q[1]\n\n[[1]]\n[1]  2  3  4 57 85\n\nwm_q[[1]]\n\n[1]  2  3  4 57 85\n\n\nNext we will retrieve the name of polygon 1:\n\nhunan$County[1]\n\n[1] \"Anxiang\"\n\n\nWe will next reveal the neighbouring counties of Anxiang:\n\nhunan$NAME_3[c(2,3,4,57,85)]\n\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n\n\nWe can also retrieve the neighbouring GDPPC of the five countries by code chunk below:\n**Note: we can save the neighbor as a list.\n**Then we will just use that as the input for filtering\n\nnb_1 <- wm_q[[1]]\nnb_1 <- hunan$GDPPC[nb_1]\nnb_1\n\n[1] 20981 34592 24473 21311 22879\n\n\nUsing str(), we will then display the complete weight matrix:\n\nstr(wm_q)\n\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#rook",
    "href": "in_class/ex_1/in_class_ex_1.html#rook",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Rook:",
    "text": "Rook:\nCreate the weight matrix based on the ROOK:\n\nwm_r <- poly2nb(hunan, queen = FALSE)\nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#data-preparation",
    "href": "in_class/ex_1/in_class_ex_1.html#data-preparation",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Data preparation:",
    "text": "Data preparation:\nStore the longitude:\n**~ means shorthand for writing a function\n** .x means a vector input\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\nStore the latitude:\n\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nBind the 2 above together:\n\ncoords <- cbind(longitude, latitude)\n\nCheck the head of the newly created data:\n\nhead(coords)\n\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#plot-queen",
    "href": "in_class/ex_1/in_class_ex_1.html#plot-queen",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Plot QUEEN:",
    "text": "Plot QUEEN:\nNext we will plot the contiguity based neighbors map:\n\nplot(hunan$geometry, border = \"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#plot-rook",
    "href": "in_class/ex_1/in_class_ex_1.html#plot-rook",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Plot ROOK:",
    "text": "Plot ROOK:\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\n\n\n\n\nPlotting both maps together:\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\", main=\"Queen Contiguity\")\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\", main=\"Rook Contiguity\")"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#compute-the-neighbors",
    "href": "in_class/ex_1/in_class_ex_1.html#compute-the-neighbors",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Compute the neighbors:",
    "text": "Compute the neighbors:\nCalculate the nearest neighbor:\n**k is default value 1\n\nk1 <- knn2nb(knearneigh(coords))\n\nHere we see that each polygon only has 1 neighbor:\n\nstr(k1)\n\nList of 88\n $ : int 3\n $ : int 78\n $ : int 1\n $ : int 5\n $ : int 4\n $ : int 69\n $ : int 67\n $ : int 46\n $ : int 84\n $ : int 70\n $ : int 72\n $ : int 63\n $ : int 12\n $ : int 17\n $ : int 13\n $ : int 22\n $ : int 16\n $ : int 20\n $ : int 21\n $ : int 82\n $ : int 19\n $ : int 16\n $ : int 41\n $ : int 54\n $ : int 81\n $ : int 81\n $ : int 29\n $ : int 49\n $ : int 27\n $ : int 33\n $ : int 24\n $ : int 50\n $ : int 28\n $ : int 45\n $ : int 47\n $ : int 34\n $ : int 42\n $ : int 44\n $ : int 43\n $ : int 39\n $ : int 23\n $ : int 37\n $ : int 44\n $ : int 43\n $ : int 34\n $ : int 47\n $ : int 46\n $ : int 51\n $ : int 28\n $ : int 52\n $ : int 48\n $ : int 54\n $ : int 55\n $ : int 52\n $ : int 50\n $ : int 36\n $ : int 58\n $ : int 57\n $ : int 87\n $ : int 13\n $ : int 63\n $ : int 61\n $ : int 12\n $ : int 57\n $ : int 76\n $ : int 68\n $ : int 7\n $ : int 66\n $ : int 6\n $ : int 10\n $ : int 74\n $ : int 11\n $ : int 70\n $ : int 71\n $ : int 55\n $ : int 65\n $ : int 38\n $ : int 2\n $ : int 45\n $ : int 34\n $ : int 25\n $ : int 21\n $ : int 12\n $ : int 9\n $ : int 5\n $ : int 74\n $ : int 61\n $ : int 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 1\n - attr(*, \"class\")= chr \"nb\"\n\n\ncompute the distance between all neighbors:\n\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nSummary report shows that the max value is 61.79, so this value will be used as the upper threshold"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#compute-the-weight-matrix",
    "href": "in_class/ex_1/in_class_ex_1.html#compute-the-weight-matrix",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Compute the weight matrix:",
    "text": "Compute the weight matrix:\nWe compute the distance weight matrix as follow:\n**0 is min threshold\n**62 is max threshold\n\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\n**Average number of links here refers to the average number of nearest neighbor per polygon\nDisplay the weight matrix:\n\nstr(wm_d62)\n\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n\n\nAn alternative way to present the data:\n\ntable(hunan$County, card(wm_d62))\n\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n\n\nFind number of disjoint sub graph:\nhttps://r4gdsa.netlify.app/chap03.html#computing-distance-based-neighbours\n\nn_comp <- n.comp.nb(wm_d62)\nn_comp$nc\n\n[1] 1\n\n\n\ntable(n_comp$comp.id)\n\n\n 1 \n88"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#plot-the-distance-based-weight-matrix",
    "href": "in_class/ex_1/in_class_ex_1.html#plot-the-distance-based-weight-matrix",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Plot the distance based weight matrix:",
    "text": "Plot the distance based weight matrix:\nPlot the distance based neighbor + K1 nearest neighbor:\n**Note it is an overlap of 2 plots on 1\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE)\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\n\n\n\n\nPlot the distance based + K nearest neighbor on 2 separate plots:\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\")\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08, main=\"1st nearest neighbours\")\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6, main=\"Distance link\")"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#compute-adaptive-distance-weight-matrix",
    "href": "in_class/ex_1/in_class_ex_1.html#compute-adaptive-distance-weight-matrix",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Compute adaptive distance weight matrix:",
    "text": "Compute adaptive distance weight matrix:\nRecalculate the N nearest neighbors, this time using K = 6\n\nknn6 <- knn2nb(knearneigh(coords, k=6))\nknn6\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n\n\nCheck the output:\n\nstr(knn6)\n\nList of 88\n $ : int [1:6] 2 3 4 5 57 64\n $ : int [1:6] 1 3 57 58 78 85\n $ : int [1:6] 1 2 4 5 57 85\n $ : int [1:6] 1 3 5 6 69 85\n $ : int [1:6] 1 3 4 6 69 85\n $ : int [1:6] 3 4 5 69 75 85\n $ : int [1:6] 9 66 67 71 74 84\n $ : int [1:6] 9 46 47 78 80 86\n $ : int [1:6] 8 46 66 68 84 86\n $ : int [1:6] 16 19 22 70 72 73\n $ : int [1:6] 10 14 16 17 70 72\n $ : int [1:6] 13 15 60 61 63 83\n $ : int [1:6] 12 15 60 61 63 83\n $ : int [1:6] 11 15 16 17 72 83\n $ : int [1:6] 12 13 14 17 60 83\n $ : int [1:6] 10 11 17 22 72 83\n $ : int [1:6] 10 11 14 16 72 83\n $ : int [1:6] 20 22 23 63 77 83\n $ : int [1:6] 10 20 21 73 74 82\n $ : int [1:6] 18 19 21 22 23 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:6] 10 16 18 19 20 83\n $ : int [1:6] 18 20 41 77 79 82\n $ : int [1:6] 25 28 31 52 54 81\n $ : int [1:6] 24 28 31 33 54 81\n $ : int [1:6] 25 27 29 33 42 81\n $ : int [1:6] 26 29 30 37 42 81\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:6] 26 27 37 42 43 81\n $ : int [1:6] 26 27 28 33 49 81\n $ : int [1:6] 24 25 36 39 40 54\n $ : int [1:6] 24 31 50 54 55 56\n $ : int [1:6] 25 26 28 30 49 81\n $ : int [1:6] 36 40 41 45 56 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:6] 26 27 29 42 43 44\n $ : int [1:6] 23 43 44 62 77 79\n $ : int [1:6] 25 40 42 43 44 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:6] 26 27 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:6] 37 38 39 42 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:6] 8 9 35 47 78 86\n $ : int [1:6] 8 21 35 46 80 86\n $ : int [1:6] 49 50 51 52 53 55\n $ : int [1:6] 28 33 48 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:6] 28 48 49 50 52 54\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:6] 48 50 51 52 55 75\n $ : int [1:6] 24 28 49 50 51 52\n $ : int [1:6] 32 48 50 52 53 75\n $ : int [1:6] 32 34 36 78 80 85\n $ : int [1:6] 1 2 3 58 64 68\n $ : int [1:6] 2 57 64 66 68 78\n $ : int [1:6] 12 13 60 61 87 88\n $ : int [1:6] 12 13 59 61 63 87\n $ : int [1:6] 12 13 60 62 63 87\n $ : int [1:6] 12 38 61 63 77 87\n $ : int [1:6] 12 18 60 61 62 83\n $ : int [1:6] 1 3 57 58 68 76\n $ : int [1:6] 58 64 66 67 68 76\n $ : int [1:6] 9 58 67 68 76 84\n $ : int [1:6] 7 65 66 68 76 84\n $ : int [1:6] 9 57 58 66 78 84\n $ : int [1:6] 4 5 6 32 75 85\n $ : int [1:6] 10 16 19 22 72 73\n $ : int [1:6] 7 19 73 74 84 86\n $ : int [1:6] 10 11 14 16 17 70\n $ : int [1:6] 10 19 21 70 71 74\n $ : int [1:6] 19 21 71 73 84 86\n $ : int [1:6] 6 32 50 53 55 69\n $ : int [1:6] 58 64 65 66 67 68\n $ : int [1:6] 18 23 38 61 62 63\n $ : int [1:6] 2 8 9 46 58 68\n $ : int [1:6] 38 40 41 43 44 45\n $ : int [1:6] 34 35 36 41 45 47\n $ : int [1:6] 25 26 28 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:6] 12 13 15 16 22 63\n $ : int [1:6] 7 9 66 68 71 74\n $ : int [1:6] 2 3 4 5 56 69\n $ : int [1:6] 8 9 21 46 47 74\n $ : int [1:6] 59 60 61 62 63 88\n $ : int [1:6] 59 60 61 62 63 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 6)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 6\n - attr(*, \"class\")= chr \"nb\"\n\n\nPlot the new K = 6:\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = \"black\")"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#spatial-lag-with-row-standardized-weights",
    "href": "in_class/ex_1/in_class_ex_1.html#spatial-lag-with-row-standardized-weights",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Spatial lag with row-standardized weights:",
    "text": "Spatial lag with row-standardized weights:\nCompute the spatial lag:\n\nGDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)\n\nThe lag for the first polygon is:\n\nGDPPC.lag[1]\n\n[1] 24847.2\n\n\nThe GDPPC of the first polygon’s neighbor are:\n\nnb1 <- wm_q[[1]]\nnb1 <- hunan$GDPPC[nb1]\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\nTheir total is:\n\nsum(nb1)\n\n[1] 124236\n\n\nTheir average is:\n\nsum(nb1)/5\n\n[1] 24847.2\n\n\nSo their weighted averaged is the value of the lag of the first polygon.\nAppend the values:\n\nlag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))\nlag.res <- as.data.frame(lag.list)\ncolnames(lag.res) <- c(\"NAME_3\", \"lag GDPPC\")\nhunan <- left_join(hunan,lag.res)\n\nJoining, by = \"NAME_3\"\n\n\n\nhead(hunan)\n\nSimple feature collection with 6 features and 36 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3 Shape_Leng Shape_Area  County    City\n1 Changde 21098 Anxiang      County   1.869074 0.10056190 Anxiang Changde\n2 Changde 21100 Hanshou      County   2.360691 0.19978745 Hanshou Changde\n3 Changde 21101  Jinshi County City   1.425620 0.05302413  Jinshi Changde\n4 Changde 21102      Li      County   3.474325 0.18908121      Li Changde\n5 Changde 21103   Linli      County   2.289506 0.11450357   Linli Changde\n6 Changde 21104  Shimen      County   4.171918 0.37194707  Shimen Changde\n  avg_wage deposite     FAI Gov_Rev Gov_Exp     GDP GDPPC     GIO   Loan  NIPCR\n1    31935   5517.2  3541.0  243.64  1779.5 12482.0 23667  5108.9 2806.9 7693.7\n2    32265   7979.0  8665.0  386.13  2062.4 15788.0 20981 13491.0 4550.0 8269.9\n3    28692   4581.7  4777.0  373.31  1148.4  8706.9 34592 10935.0 2242.0 8169.9\n4    32541  13487.0 16066.0  709.61  2459.5 20322.0 24473 18402.0 6748.0 8377.0\n5    32667    564.1  7781.2  336.86  1538.7 10355.0 25554  8214.0  358.0 8143.1\n6    33261   8334.4 10531.0  548.33  2178.8 16293.0 27137 17795.0 6026.5 6156.0\n   Bed    Emp  EmpR EmpRT Pri_Stu Sec_Stu Household Household_R NOIP Pop_R\n1 1931 336.39 270.5 205.9  19.584  17.819     148.1       135.4   53 346.0\n2 2560 456.78 388.8 246.7  42.097  33.029     240.2       208.7   95 553.2\n3  848 122.78  82.1  61.7   8.723   7.592      81.9        43.7   77  92.4\n4 2038 513.44 426.8 227.1  38.975  33.938     268.5       256.0   96 539.7\n5 1440 307.36 272.2 100.8  23.286  18.943     129.1       157.2   99 246.6\n6 2502 392.05 329.6 193.8  29.245  26.104     190.6       184.7  122 399.2\n    RSCG Pop_T    Agri Service Disp_Inc      RORP    ROREmp lag GDPPC\n1 3957.9 528.3 4524.41   14100    16610 0.6549309 0.8041262  24847.20\n2 4460.5 804.6 6545.35   17727    18925 0.6875466 0.8511756  22724.80\n3 3683.0 251.8 2562.46    7525    19498 0.3669579 0.6686757  24143.25\n4 7110.2 832.5 7562.34   53160    18985 0.6482883 0.8312558  27737.50\n5 3604.9 409.3 3583.91    7031    18604 0.6024921 0.8856065  27270.25\n6 6490.7 600.5 5266.51    6981    19275 0.6647794 0.8407091  21248.80\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n\n\nPlot the lag GDPPPC:\n\ngdppc <- qtm(hunan, \"GDPPC\")\nlag_gdppc <- qtm(hunan, \"lag GDPPC\")\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#spatial-lag-as-sum-of-neighbouring-values",
    "href": "in_class/ex_1/in_class_ex_1.html#spatial-lag-as-sum-of-neighbouring-values",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Spatial lag as sum of neighbouring values:",
    "text": "Spatial lag as sum of neighbouring values:\nCalculate the weights:\n\nb_weights <- lapply(wm_q, function(x) 0*x + 1)\nb_weights2 <- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n\n\nCompute lag variable:\n\nlag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nlag.res <- as.data.frame(lag_sum)\ncolnames(lag.res) <- c(\"NAME_3\", \"lag_sum GDPPC\")\n\nExamine the output:\n\nlag_sum\n\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n\n\nJoin the data:\n\nhunan <- left_join(hunan, lag.res)\n\nJoining, by = \"NAME_3\"\n\n\nPlot the lag sum:\n\ngdppc <- qtm(hunan, \"GDPPC\")\nlag_sum_gdppc <- qtm(hunan, \"lag_sum GDPPC\")\ntmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#spatial-window-average",
    "href": "in_class/ex_1/in_class_ex_1.html#spatial-window-average",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Spatial window average:",
    "text": "Spatial window average:\nAssign to new variable:\n\nwm_q1 <- wm_q\n\nNext we will use include.self() to set the attribute to include self in neighbor calculation.\n\ninclude.self(wm_q1)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\n\nObtain the weights:\n\nwm_q1 <- nb2listw(wm_q1)\nwm_q1\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nCreate lag variable:\n\nlag_w_avg_gpdpc <- lag.listw(wm_q1, \n                             hunan$GDPPC)\nlag_w_avg_gpdpc\n\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n\n\nConvert to dataframe:\n\nlag.list.wm_q1 <- list(hunan$NAME_3, lag.listw(wm_q1, hunan$GDPPC))\nlag_wm_q1.res <- as.data.frame(lag.list.wm_q1)\ncolnames(lag_wm_q1.res) <- c(\"NAME_3\", \"lag_window_avg GDPPC\")\n\nJoin to mainframe:\n\nhunan <- left_join(hunan, lag_wm_q1.res)\n\nJoining, by = \"NAME_3\"\n\n\nPlot the outcome:\n\ngdppc <- qtm(hunan, \"GDPPC\")\nw_avg_gdppc <- qtm(hunan, \"lag_window_avg GDPPC\")\ntmap_arrange(gdppc, w_avg_gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1.html#spatial-window-sum",
    "href": "in_class/ex_1/in_class_ex_1.html#spatial-window-sum",
    "title": "In Class ex 1 - Chap 3 Spatial Weights and Applications",
    "section": "Spatial Window Sum:",
    "text": "Spatial Window Sum:\nWe will not proceed without row standardized weights:\nCopy new variable\n\nwm_q1 <- wm_q\n\nSet attribute:\n\ninclude.self(wm_q1)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\n\n\nwm_q1\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\n\nApply function:\n\nb_weights <- lapply(wm_q1, function(x) 0*x + 1)\nb_weights[1]\n\n[[1]]\n[1] 1 1 1 1 1\n\n\nGet weight values:\n\nb_weights2 <- nb2listw(wm_q1, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n\n\nCompute lag variable:\n\nw_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nw_sum_gdppc\n\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n\n\nConvert result into dataframe:\n\nw_sum_gdppc.res <- as.data.frame(w_sum_gdppc)\ncolnames(w_sum_gdppc.res) <- c(\"NAME_3\", \"w_sum GDPPC\")\n\nJoin to main frame:\n\nhunan <- left_join(hunan, w_sum_gdppc.res)\n\nJoining, by = \"NAME_3\"\n\n\nPlot the results:\n\ngdppc <- qtm(hunan, \"GDPPC\")\nw_sum_gdppc <- qtm(hunan, \"w_sum GDPPC\")\ntmap_arrange(gdppc, w_sum_gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "in_class/ex_1/in_class_ex_1_old.html",
    "href": "in_class/ex_1/in_class_ex_1_old.html",
    "title": "in_class_ex_1",
    "section": "",
    "text": "This is xxx\nGetting Started\nInstall and load the tidyverse and sf packages.\n\npacman::p_load(sf, tidyverse, spdep)\n\nImport Geo spatial data\nImport Polygon\n\nhunan_sf <- st_read(dsn = \"dataH/geospatial\", \n                  layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `D:\\f4sared\\ISSS624\\in_class\\ex_1\\dataH\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\nImporting and transforming using a nested piping\n\nhunan <- read_csv(\"dataH/aspatial/Hunan_2012.csv\") \n\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "in_class/ex_2/ex_2.html#import-nigeria-water-point-data-file",
    "href": "in_class/ex_2/ex_2.html#import-nigeria-water-point-data-file",
    "title": "In-Class Ex 2 - Loading data + prepare data for take home Ex 1",
    "section": "Import Nigeria water point data-file:",
    "text": "Import Nigeria water point data-file:\nGenerate a path:\nWe use the here function to generate a specific file path on the root folder.\n\nshapefile_path <- here(\"data\", \"dataNigeria\", \"geospatial\")\nshapefile_path\n\n[1] \"D:/f4sared/ISSS624/data/dataNigeria/geospatial\"\n\n\nSome useful link for the CRS:\n\nhttps://datacarpentry.org/organization-geospatial/03-crs/\nhttps://www.nceas.ucsb.edu/sites/default/files/2020-04/OverviewCoordinateReferenceSystems.pdf\n\nst_read() belongs to the sf package. It reads simple features from file or database. Simple features or simple feature access refers to formal standard ISO 19125-1:2004 that describes how real world data can be represented in computers, with emphasis on the spatial geometry of these objects. Link below:\nhttps://cran.r-project.org/web/packages/sf/vignettes/sf1.html#:~:text=Simple%20features%20or%20simple%20feature,spatial%20geometry%20of%20these%20objects.\nTo find the CRS of the shapefile, open the .prj file as a text. It will tell you which projection system is being used.\nRead the shapefile using st_read() belonging to the sf package:\nThe data read will be saved as a simple feature data table.\nWe will use the filter() function of dplyr package to filter only rows for Nigeria\n\n# wp <- st_read(\n#   dsn = shapefile_path,\n#   layer = \"geo_export\",\n#   crs = 4326) %>%\n#   filter(clean_coun == \"Nigeria\")\n\nGenerate the save path using here function:\n\nsavefile_path <- here(\"data\", \"dataNigeria\", \"geospatial\", \"wp_nga.rds\")\nsavefile_path\n\n[1] \"D:/f4sared/ISSS624/data/dataNigeria/geospatial/wp_nga.rds\"\n\n\nWe will next save the file using write_rds() of the tidyverse package:\nrds is a native data format of R.\n\n# wp_ng <- write_rds(wp, savefile_path)"
  },
  {
    "objectID": "in_class/ex_2/ex_2.html#import-nigeria-geo-boundary-file",
    "href": "in_class/ex_2/ex_2.html#import-nigeria-geo-boundary-file",
    "title": "In-Class Ex 2 - Loading data + prepare data for take home Ex 1",
    "section": "Import Nigeria geo-boundary file:",
    "text": "Import Nigeria geo-boundary file:\nNext we will make the path to the geo boundary file:\n\nshapefile_path <- here(\"data\", \"dataNigeria\", \"boundary\")\nshapefile_path\n\n[1] \"D:/f4sared/ISSS624/data/dataNigeria/boundary\"\n\n\nNext we will Import the Nigeria LGA Boundary Data with st_read() function:\nThe imported data will be saved as a simple features dataset.\n\nnga <- st_read(\n  dsn = shapefile_path,\n  layer = \"geoBoundaries-NGA-ADM2\",\n  crs = 4326)\n\nReading layer `geoBoundaries-NGA-ADM2' from data source \n  `D:\\f4sared\\ISSS624\\data\\dataNigeria\\boundary' using driver `ESRI Shapefile'\nSimple feature collection with 774 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84"
  },
  {
    "objectID": "in_class/ex_2/ex_2.html#downsize-further-the-wp_nga-data",
    "href": "in_class/ex_2/ex_2.html#downsize-further-the-wp_nga-data",
    "title": "In-Class Ex 2 - Loading data + prepare data for take home Ex 1",
    "section": "Downsize further the wp_nga data:",
    "text": "Downsize further the wp_nga data:\nLoad the previously saved data:\nWe will select specific columns using select().\n\n# final <- read_rds(rdsfile_path) %>% select(1:2, 14:17, 23)\n\nCreate the path for saving the file\n\n# savefile_path <- here(\"data\", \"dataNigeria\", \"geospatial\", \"wp_nga_v2.rds\")\n# savefile_path\n\nSave the file:\n\n# write_rds(final, savefile_path)"
  },
  {
    "objectID": "in_class/ex_2/ex_2.html#visualize-initial-distribution",
    "href": "in_class/ex_2/ex_2.html#visualize-initial-distribution",
    "title": "In-Class Ex 2 - Loading data + prepare data for take home Ex 1",
    "section": "Visualize Initial distribution",
    "text": "Visualize Initial distribution\nGenerate path to rds file saved previously:\n\nrdsfile_path <- here(\"data\", \"dataNigeria\", \"geospatial\",\"wp_nga_v2.rds\")\nrdsfile_path\n\n[1] \"D:/f4sared/ISSS624/data/dataNigeria/geospatial/wp_nga_v2.rds\"\n\n\nLoad the rds file with read_rds() function of the tidyverse package:\nWe will also make use of the piping to replace the “na” values with “unknown”.\nmutate() is a function of the dplyr package.\n\nwp_nga <- read_rds(rdsfile_path) %>%\n  mutate(status_cle = replace_na(status_cle, \"Unknown\"))\n\nCheck the CRS of the spatial datafile with st_crs():\n\nst_crs(wp_nga)\n\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\n\nUse the freq() of the funModeling package to show the distribution percentage of status_cle:\n\nfreq(data=wp_nga,\n     input = 'status_cle')\n\nWarning: The `<scale>` argument of `guides()` cannot be `FALSE`. Use \"none\" instead as\nof ggplot2 3.3.4.\nℹ The deprecated feature was likely used in the funModeling package.\n  Please report the issue at <https://github.com/pablo14/funModeling/issues>.\n\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                       Functional     45883      48.29           48.29\n2                   Non-Functional     29385      30.93           79.22\n3                          Unknown     10656      11.22           90.44\n4      Functional but needs repair      4579       4.82           95.26\n5 Non-Functional due to dry season      2403       2.53           97.79\n6        Functional but not in use      1686       1.77           99.56\n7         Abandoned/Decommissioned       234       0.25           99.81\n8                        Abandoned       175       0.18           99.99\n9 Non functional due to dry season         7       0.01          100.00"
  },
  {
    "objectID": "in_class/ex_2/ex_2.html#filter-for-functional-water-points",
    "href": "in_class/ex_2/ex_2.html#filter-for-functional-water-points",
    "title": "In-Class Ex 2 - Loading data + prepare data for take home Ex 1",
    "section": "Filter for functional water-points:",
    "text": "Filter for functional water-points:\nHere we will use the filter() function from the dplyr package to select “functional” rows only:\nWe use the %in% to denote the membership in the group of strings.\n\nwpt_functional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Functional\",\n             \"Functional but not in use\",\n             \"Functional but needs repair\"))\n\nThen we will plot with freq() function from funModeling to show the distribution:\n\nfreq(data=wpt_functional, \n     input = 'status_cle')\n\n\n\n\n                   status_cle frequency percentage cumulative_perc\n1                  Functional     45883      87.99           87.99\n2 Functional but needs repair      4579       8.78           96.77\n3   Functional but not in use      1686       3.23          100.00"
  },
  {
    "objectID": "in_class/ex_2/ex_2.html#filter-for-non-functional",
    "href": "in_class/ex_2/ex_2.html#filter-for-non-functional",
    "title": "In-Class Ex 2 - Loading data + prepare data for take home Ex 1",
    "section": "Filter for non-functional",
    "text": "Filter for non-functional\nFilter for non-functional rows:\nUse %in% for to select rows that fall into the specific categories.\n\nwpt_nonfunctional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Abandoned/Decommissioned\", \n             \"Abandoned\",\n             \"Non-Functional\",\n             \"Non functional due to dry season\",\n             \"Non-Functional due to dry season\"))\n\nPlot the distribution with the freq() function:\n\nfreq(data=wpt_nonfunctional, \n     input = 'status_cle')\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                   Non-Functional     29385      91.25           91.25\n2 Non-Functional due to dry season      2403       7.46           98.71\n3         Abandoned/Decommissioned       234       0.73           99.44\n4                        Abandoned       175       0.54           99.98\n5 Non functional due to dry season         7       0.02          100.00"
  },
  {
    "objectID": "in_class/ex_2/ex_2.html#filter-for-unknown",
    "href": "in_class/ex_2/ex_2.html#filter-for-unknown",
    "title": "In-Class Ex 2 - Loading data + prepare data for take home Ex 1",
    "section": "Filter for unknown:",
    "text": "Filter for unknown:\nLastly we filter for the rows that have unknown status:\n\nwpt_unknown <- wp_nga %>%\n  filter(status_cle == \"Unknown\")"
  },
  {
    "objectID": "in_class/ex_2/ex_2.html#perform-data-manipulation",
    "href": "in_class/ex_2/ex_2.html#perform-data-manipulation",
    "title": "In-Class Ex 2 - Loading data + prepare data for take home Ex 1",
    "section": "Perform data manipulation:",
    "text": "Perform data manipulation:\nUsing st_intersects, we will be able to create a list of rows from wp_nga that intersects each row of nga.\nFor the intersection to work, st_intersect will check if each point falls within the polygon of nga.\nNext we use the lengths() function to count the number of instances. Then we append to a new column.\nWe repeat this step across all 3 categories of Functional, Non-Functional & Unknown\n\nnga_wp <- nga %>%\n  mutate(`total wpt` = lengths(\n    st_intersects(nga, wp_nga))) %>%\n  mutate(`wpt functional` = lengths(\n    st_intersects(nga, wpt_functional))) %>%\n  mutate(`wpt non-functional` = lengths(\n    st_intersects(nga, wpt_nonfunctional))) %>%\n  mutate(`wpt unknown` = lengths(\n    st_intersects(nga, wpt_unknown)))\n\nNext, using the mutate() function of dplyr, we will create 2 new columns:\n\npct_functional = `wpt functional`/`total wpt`\npct_non-functional = `wpt non-functional`/`total wpt`\n\nWe will then use select() of dplyr to retain the fields that we require.\n\nnga_wp <- nga_wp %>%\n  mutate(pct_functional = `wpt functional`/`total wpt`) %>%\n  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`) \n# select(3:4, 9:10, 18:23)\n\nWe will then create a save file path:\n\nsavefile_path <- here(\"data\", \"dataNigeria\", \"geospatial\", \"nga_wp.rds\")\nsavefile_path\n\n[1] \"D:/f4sared/ISSS624/data/dataNigeria/geospatial/nga_wp.rds\"\n\n\nNext we will save this final dataframe using write_rds of tidyverse package:\n\nwrite_rds(nga_wp, savefile_path)"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#import-nigeria-water-point-data-file",
    "href": "take_home_ex/ex_1/ex_1.html#import-nigeria-water-point-data-file",
    "title": "Take Home Ex-1",
    "section": "Import Nigeria water point data-file:",
    "text": "Import Nigeria water point data-file:\nGenerate a path:\nWe use the here function to generate a specific file path on the root folder.\n\nshapefile_path <- here(\"data\", \"dataNigeria\", \"geospatial\")\nshapefile_path\n\n[1] \"D:/f4sared/ISSS624/data/dataNigeria/geospatial\"\n\n\nSome useful link for the CRS:\n\nhttps://datacarpentry.org/organization-geospatial/03-crs/\nhttps://www.nceas.ucsb.edu/sites/default/files/2020-04/OverviewCoordinateReferenceSystems.pdf\n\nst_read() belongs to the sf package. It reads simple features from file or database. Simple features or simple feature access refers to formal standard ISO 19125-1:2004 that describes how real world data can be represented in computers, with emphasis on the spatial geometry of these objects. Link below:\nhttps://cran.r-project.org/web/packages/sf/vignettes/sf1.html#:~:text=Simple%20features%20or%20simple%20feature,spatial%20geometry%20of%20these%20objects.\nTo find the CRS of the shapefile, open the .prj file as a text. It will tell you which projection system is being used.\nRead the shapefile using st_read() belonging to the sf package:\nThe data read will be saved as a simple feature data table.\nWe will use the filter() function of dplyr package to filter only rows for Nigeria\n\n# wp <- st_read(\n#   dsn = shapefile_path,\n#   layer = \"geo_export\",\n#   crs = 4326) %>%\n#   filter(clean_coun == \"Nigeria\")\n\nGenerate the save path using here function:\n\nsavefile_path <- here(\"data\", \"dataNigeria\", \"geospatial\", \"wp_nga.rds\")\nsavefile_path\n\n[1] \"D:/f4sared/ISSS624/data/dataNigeria/geospatial/wp_nga.rds\"\n\n\nWe will next save the file using write_rds() of the tidyverse package:\nrds is a native data format of R.\n\n# wp_ng <- write_rds(wp, savefile_path)"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#import-nigeria-geo-boundary-file",
    "href": "take_home_ex/ex_1/ex_1.html#import-nigeria-geo-boundary-file",
    "title": "Take Home Ex-1",
    "section": "Import Nigeria geo-boundary file:",
    "text": "Import Nigeria geo-boundary file:\nNext we will make the path to the geo boundary file:\n\nshapefile_path <- here(\"data\", \"dataNigeria\", \"boundary\")\nshapefile_path\n\n[1] \"D:/f4sared/ISSS624/data/dataNigeria/boundary\"\n\n\nNext we will Import the Nigeria LGA Boundary Data with st_read() function:\nThe imported data will be saved as a simple features dataset.\n\nnga <- st_read(\n  dsn = shapefile_path,\n  layer = \"geoBoundaries-NGA-ADM2\",\n  crs = 4326)\n\nReading layer `geoBoundaries-NGA-ADM2' from data source \n  `D:\\f4sared\\ISSS624\\data\\dataNigeria\\boundary' using driver `ESRI Shapefile'\nSimple feature collection with 774 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#downsize-further-the-wp_nga-data",
    "href": "take_home_ex/ex_1/ex_1.html#downsize-further-the-wp_nga-data",
    "title": "Take Home Ex-1",
    "section": "Downsize further the wp_nga data:",
    "text": "Downsize further the wp_nga data:\nLoad the previously saved data:\nWe will select specific columns using select().\n\n# final <- read_rds(rdsfile_path) %>% select(1:2, 14:17, 23)\n\nCreate the path for saving the file\n\n# savefile_path <- here(\"data\", \"dataNigeria\", \"geospatial\", \"wp_nga_v2.rds\")\n# savefile_path\n\nSave the file:\n\n# write_rds(final, savefile_path)"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#visualize-initial-distribution",
    "href": "take_home_ex/ex_1/ex_1.html#visualize-initial-distribution",
    "title": "Take Home Ex-1",
    "section": "Visualize Initial distribution",
    "text": "Visualize Initial distribution\nGenerate path to rds file saved previously:\n\nrdsfile_path <- here(\"data\", \"dataNigeria\", \"geospatial\",\"wp_nga_v2.rds\")\nrdsfile_path\n\n[1] \"D:/f4sared/ISSS624/data/dataNigeria/geospatial/wp_nga_v2.rds\"\n\n\nLoad the rds file with read_rds() function of the tidyverse package:\nWe will also make use of the piping to replace the “na” values with “unknown”.\nmutate() is a function of the dplyr package.\n\nwp_nga <- read_rds(rdsfile_path) %>%\n  mutate(status_cle = replace_na(status_cle, \"Unknown\"))\n\nCheck the CRS of the spatial datafile with st_crs():\n\nst_crs(wp_nga)\n\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\n\nUse the freq() of the funModeling package to show the distribution percentage of status_cle:\n\nfreq(data=wp_nga,\n     input = 'status_cle')\n\nWarning: The `<scale>` argument of `guides()` cannot be `FALSE`. Use \"none\" instead as\nof ggplot2 3.3.4.\nℹ The deprecated feature was likely used in the funModeling package.\n  Please report the issue at <https://github.com/pablo14/funModeling/issues>.\n\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                       Functional     45883      48.29           48.29\n2                   Non-Functional     29385      30.93           79.22\n3                          Unknown     10656      11.22           90.44\n4      Functional but needs repair      4579       4.82           95.26\n5 Non-Functional due to dry season      2403       2.53           97.79\n6        Functional but not in use      1686       1.77           99.56\n7         Abandoned/Decommissioned       234       0.25           99.81\n8                        Abandoned       175       0.18           99.99\n9 Non functional due to dry season         7       0.01          100.00"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#filter-for-functional-water-points",
    "href": "take_home_ex/ex_1/ex_1.html#filter-for-functional-water-points",
    "title": "Take Home Ex-1",
    "section": "Filter for functional water-points:",
    "text": "Filter for functional water-points:\nHere we will use the filter() function from the dplyr package to select “functional” rows only:\nWe use the %in% to denote the membership in the group of strings.\n\nwpt_functional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Functional\",\n             \"Functional but not in use\",\n             \"Functional but needs repair\"))\n\nThen we will plot with freq() function from funModeling to show the distribution:\n\nfreq(data=wpt_functional, \n     input = 'status_cle')\n\n\n\n\n                   status_cle frequency percentage cumulative_perc\n1                  Functional     45883      87.99           87.99\n2 Functional but needs repair      4579       8.78           96.77\n3   Functional but not in use      1686       3.23          100.00"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#filter-for-non-functional",
    "href": "take_home_ex/ex_1/ex_1.html#filter-for-non-functional",
    "title": "Take Home Ex-1",
    "section": "Filter for non-functional",
    "text": "Filter for non-functional\nFilter for non-functional rows:\nUse %in% for to select rows that fall into the specific categories.\n\nwpt_nonfunctional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Abandoned/Decommissioned\", \n             \"Abandoned\",\n             \"Non-Functional\",\n             \"Non functional due to dry season\",\n             \"Non-Functional due to dry season\"))\n\nPlot the distribution with the freq() function:\n\nfreq(data=wpt_nonfunctional, \n     input = 'status_cle')\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                   Non-Functional     29385      91.25           91.25\n2 Non-Functional due to dry season      2403       7.46           98.71\n3         Abandoned/Decommissioned       234       0.73           99.44\n4                        Abandoned       175       0.54           99.98\n5 Non functional due to dry season         7       0.02          100.00"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#filter-for-unknown",
    "href": "take_home_ex/ex_1/ex_1.html#filter-for-unknown",
    "title": "Take Home Ex-1",
    "section": "Filter for unknown:",
    "text": "Filter for unknown:\nLastly we filter for the rows that have unknown status:\n\nwpt_unknown <- wp_nga %>%\n  filter(status_cle == \"Unknown\")"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#perform-data-manipulation-point-in-polygon",
    "href": "take_home_ex/ex_1/ex_1.html#perform-data-manipulation-point-in-polygon",
    "title": "Take Home Ex-1",
    "section": "Perform data manipulation (Point-In-Polygon):",
    "text": "Perform data manipulation (Point-In-Polygon):\nUsing st_intersects, we will be able to create a list of rows from wp_nga that intersects each row of nga.\nFor the intersection to work, st_intersect will check if each point falls within the polygon of nga.\nNext we use the lengths() function to count the number of instances. Then we append to a new column.\nWe repeat this step across all 3 categories of Functional, Non-Functional & Unknown:\n\nnga_wp <- nga %>%\n  mutate(`total wpt` = lengths(\n    st_intersects(nga, wp_nga))) %>%\n  mutate(`wpt functional` = lengths(\n    st_intersects(nga, wpt_functional))) %>%\n  mutate(`wpt non-functional` = lengths(\n    st_intersects(nga, wpt_nonfunctional))) %>%\n  mutate(`wpt unknown` = lengths(\n    st_intersects(nga, wpt_unknown)))\n\nNext, using the mutate() function of dplyr, we will create 2 new columns:\n\npct_functional = `wpt functional`/`total wpt`\npct_non-functional = `wpt non-functional`/`total wpt`\n\nWe will then use select() of dplyr to retain the fields that we require.\n\nnga_wp <- nga_wp %>%\n  mutate(pct_functional = `wpt functional`/`total wpt`) %>%\n  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`) \n\nWe will then create a save file path:\n\nsavefile_path <- here(\"data\", \"dataNigeria\", \"geospatial\", \"nga_wp.rds\")\nsavefile_path\n\n[1] \"D:/f4sared/ISSS624/data/dataNigeria/geospatial/nga_wp.rds\"\n\n\nNext we will save this final dataframe using write_rds() of tidyverse package:\n\nwrite_rds(nga_wp, savefile_path)"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#plotting-with-qtm",
    "href": "take_home_ex/ex_1/ex_1.html#plotting-with-qtm",
    "title": "Take Home Ex-1",
    "section": "Plotting with qtm()",
    "text": "Plotting with qtm()\nSet the tmap mode to “view” for interactive mode. Else set to “plot”.\nqtm() represents quick plotting with tmap package:\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\nqtm(nga_wp_26391, \n    fill = \"wpt non-functional\")"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#plotting-with-tmap",
    "href": "take_home_ex/ex_1/ex_1.html#plotting-with-tmap",
    "title": "Take Home Ex-1",
    "section": "Plotting with tmap()",
    "text": "Plotting with tmap()\n\nJenks:\nJenks: Identify groups with similar values and maximizes the difference between them.\nUsing interactive tmap(), we will plot using “equal” classification:\n\ntmap_mode(\"view\")\n\ntmap mode set to interactive viewing\n\ntm_shape(nga_wp_26391)+\n  tm_fill(c(\"wpt non-functional\", \"wpt functional\"),\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuantile:\nSplits variables in quantiles, Consequently there are same number of observations in each interval.\nUsing interactive tmap(), we will plot using “quantile” classification:\n\ntm_shape(nga_wp_26391)+\n  tm_fill(c(\"wpt non-functional\", \"wpt functional\"),\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe will use bbox to get better visuals:\nhttps://stackoverflow.com/questions/60892033/how-do-you-position-the-title-and-legend-in-tmap\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\n# make some bbox magic\nbbox_new <- st_bbox(nga_wp_26391)\nxrange <- bbox_new$xmax - bbox_new$xmin # range of x values\nyrange <- bbox_new$ymax - bbox_new$ymin # range of y values\n# bbox_new[1] <- bbox_new[1] - (0.25 * xrange) # xmin - left\nbbox_new[3] <- bbox_new[3] + (0.75 * xrange) # xmax - right\n# bbox_new[2] <- bbox_new[2] - (0.25 * yrange) # ymin - bottom\nbbox_new[4] <- bbox_new[4] + (0.01 * yrange) # ymax - top\nbbox_new <- bbox_new %>%  # take the bounding box ...\n  st_as_sfc() # ... and make it a sf polygon\n\n\ntm_shape(nga_wp_26391, bbox = bbox_new)+\n  tm_fill(\"wpt non-functional\", \n          style = \"quantile\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.5) +\n  tm_borders(alpha = 0.5) + \n  tm_layout(main.title = \"Quantile Plot of WPT Non-Functional\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.position = c(\"right\", \"center\"),\n            frame = TRUE) + \n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.2, position= c(\"center\", \"bottom\")) +\n  tm_grid(lwd = 0.1, alpha = 0.2) \n\n\n\n\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\n# make some bbox magic\nbbox_new <- st_bbox(nga_wp_26391)\nxrange <- bbox_new$xmax - bbox_new$xmin # range of x values\nyrange <- bbox_new$ymax - bbox_new$ymin # range of y values\n# bbox_new[1] <- bbox_new[1] - (0.25 * xrange) # xmin - left\nbbox_new[3] <- bbox_new[3] + (0.75 * xrange) # xmax - right\n# bbox_new[2] <- bbox_new[2] - (0.25 * yrange) # ymin - bottom\nbbox_new[4] <- bbox_new[4] + (0.01 * yrange) # ymax - top\nbbox_new <- bbox_new %>%  # take the bounding box ...\n  st_as_sfc() # ... and make it a sf polygon\n\n\ntm_shape(nga_wp_26391, bbox = bbox_new)+\n  tm_fill(\"wpt functional\", \n          style = \"quantile\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.5) +\n  tm_borders(alpha = 0.5) + \n  tm_layout(main.title = \"Quantile Plot of WPT Non-Functional\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.position = c(\"right\", \"center\"),\n            frame = TRUE) + \n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.2, position= c(\"center\", \"bottom\")) +\n  tm_grid(lwd = 0.1, alpha = 0.2)"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#prepare-the-coordinates",
    "href": "take_home_ex/ex_1/ex_1.html#prepare-the-coordinates",
    "title": "Take Home Ex-1",
    "section": "Prepare the coordinates",
    "text": "Prepare the coordinates\nIn order to work with fixed distance weight matrix, we need to prepare the coordinates of the center of gravity (COG) for all the polygons.\nTo achieve this, we will need to pass the column “geometry” into the function st_centroid() from the sf package. This function will calculate the COG and return us the coordinates accordingly. We will also make use of the map_dbl() function from the purrr package to apply the st_centroid() function to row.\nLongitude:\n\nlongitude <- map_dbl(nga_wp_26391$geometry, ~st_centroid(.x)[[1]])\n\nLatitude:\n\nlatitude <- map_dbl(nga_wp_26391$geometry, ~st_centroid(.x)[[2]])\n\nNext, we will use the function of cbind() from the base package to bind our coordinates together.\nBind long & lat:\n\ncoords <- cbind(longitude, latitude)\n\nCheck if output is correct:\n\nhead(coords)\n\n     longitude  latitude\n[1,]  549364.0  123694.9\n[2,]  547123.4  120376.5\n[3,] 1189496.9 1059770.9\n[4,]  489057.4  534262.6\n[5,]  593718.2  113824.1\n[6,]  642618.7  251222.3"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#determine-cut-off-distance",
    "href": "take_home_ex/ex_1/ex_1.html#determine-cut-off-distance",
    "title": "Take Home Ex-1",
    "section": "Determine cut off distance:",
    "text": "Determine cut off distance:\nIn order to ensure that each polygon has at least 1 neighbor, we need to determine the cut off distance. To do this, we will first run the k-nearest neighbor with k=1. This is achieved with the function of knearneigh() of the spdep package.\nWe run the code as follow:\n\nk1 <- knn2nb(knearneigh(coords))\n\nAfter obtaining k1, a list of 774 polygons where each row shows the nearest neighbor polygon ID, we next need to calculate the distance between all of them using nbdists() of spdep.\nNext, in order to calculate the summary, we need then to unlist() the output of nbdists(). This is then followed by using the summary() function which reports to us the max distance for us to use.\nWe run the code as follow:\n\nk1dists <- unlist(nbdists(k1, coords, longlat = FALSE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   2669   12834   20304   22084   27783   72139 \n\n\nFrom the above summary, it shows that the minimum distance for every polygon to have a neighbor is 71.661, thus we will use the value 72140."
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#compute-the-fixed-distance-neighbor-list",
    "href": "take_home_ex/ex_1/ex_1.html#compute-the-fixed-distance-neighbor-list",
    "title": "Take Home Ex-1",
    "section": "Compute the fixed distance neighbor list:",
    "text": "Compute the fixed distance neighbor list:\nWith the above information, we will then compute the fixed distance weight matrix using dnearneigh() function from spdep. For this to work, we will need the coordinate of the polygons, min dist & max dist.\nWe will run the code as follow, this will give us a nb (neighbor) object data wm_d72:\n\nnb_d72 <- dnearneigh(coords, 0, 72140, longlat = FALSE)\nnb_d72\n\nNeighbour list object:\nNumber of regions: 774 \nNumber of nonzero links: 18130 \nPercentage nonzero weights: 3.026327 \nAverage number of links: 23.42377 \n\n\nNext, we will display our results for viewing:\n\nstr(nb_d72)\n\nList of 774\n $ : int [1:63] 2 5 10 25 55 66 68 103 122 181 ...\n $ : int [1:62] 1 5 10 25 55 66 68 103 122 181 ...\n $ : int [1:2] 261 447\n $ : int [1:10] 12 20 257 263 446 454 466 641 690 695\n $ : int [1:56] 1 2 55 66 104 136 137 169 184 202 ...\n $ : int [1:21] 9 14 18 19 56 170 217 218 330 337 ...\n $ : int [1:19] 8 15 22 176 177 214 281 282 283 295 ...\n $ : int [1:32] 7 15 22 49 176 177 214 275 276 277 ...\n $ : int [1:26] 6 18 19 56 66 77 103 104 217 218 ...\n $ : int [1:64] 1 2 23 25 66 103 181 190 191 203 ...\n $ : int [1:22] 26 27 43 68 126 157 190 191 204 336 ...\n $ : int [1:11] 4 135 257 263 401 417 429 446 454 690 ...\n $ : int [1:13] 31 37 38 40 94 211 320 393 436 471 ...\n $ : int [1:24] 6 170 193 194 195 217 309 310 311 362 ...\n $ : int [1:27] 7 8 22 32 49 51 62 82 176 177 ...\n $ : int [1:37] 30 38 39 41 44 45 70 71 120 124 ...\n $ : int [1:34] 28 29 35 72 172 173 178 179 182 275 ...\n $ : int [1:29] 6 9 19 56 66 77 103 104 217 218 ...\n $ : int [1:41] 6 9 18 25 56 66 77 103 104 181 ...\n $ : int [1:7] 4 106 239 263 419 454 466\n $ : int [1:9] 60 61 162 269 484 520 578 596 626\n $ : int [1:31] 7 8 15 32 49 51 62 82 176 177 ...\n $ : int [1:64] 10 25 52 53 54 56 58 77 78 79 ...\n $ : int [1:5] 123 476 527 673 761\n $ : int [1:68] 1 2 10 19 23 54 56 66 77 103 ...\n $ : int [1:30] 11 27 43 68 157 190 191 204 336 370 ...\n $ : int [1:24] 11 26 43 68 157 191 204 336 370 371 ...\n $ : int [1:43] 17 29 35 70 71 124 172 173 178 179 ...\n $ : int [1:45] 17 28 35 70 71 124 172 173 178 179 ...\n $ : int [1:30] 16 38 39 40 41 44 45 175 185 186 ...\n $ : int [1:13] 13 37 94 158 210 211 212 289 308 561 ...\n $ : int [1:28] 15 22 49 51 62 82 177 196 207 214 ...\n $ : int [1:29] 47 111 130 142 145 155 166 219 227 233 ...\n $ : int [1:11] 42 86 104 136 137 213 375 553 559 733 ...\n $ : int [1:33] 17 28 29 72 172 173 178 179 182 275 ...\n $ : int [1:8] 50 107 247 408 432 455 681 759\n $ : int [1:21] 13 31 38 39 40 41 186 192 197 198 ...\n $ : int [1:25] 13 16 30 37 39 40 41 44 186 192 ...\n $ : int [1:27] 16 30 37 38 40 41 44 185 186 192 ...\n $ : int [1:21] 13 30 37 38 39 41 44 186 192 211 ...\n $ : int [1:22] 16 30 37 38 39 40 44 45 186 192 ...\n $ : int [1:20] 34 86 136 137 184 202 285 286 375 499 ...\n $ : int [1:19] 11 26 27 68 122 126 157 190 191 246 ...\n $ : int [1:27] 16 30 38 39 40 41 45 70 175 186 ...\n $ : int [1:27] 16 30 41 44 70 175 187 188 192 290 ...\n $ : int [1:12] 119 380 387 417 423 429 438 459 521 656 ...\n $ : int [1:24] 33 111 127 130 155 166 227 234 238 242 ...\n $ : int [1:12] 64 65 74 113 131 265 386 407 428 482 ...\n $ : int [1:30] 8 15 22 32 51 62 82 176 177 207 ...\n $ : int [1:4] 36 107 409 432\n $ : int [1:27] 15 22 32 49 62 82 177 207 214 284 ...\n $ : int [1:47] 23 53 54 57 58 77 78 79 80 165 ...\n $ : int [1:37] 23 52 54 57 58 78 79 80 165 189 ...\n $ : int [1:58] 23 25 52 53 56 57 58 77 78 79 ...\n $ : int [1:33] 1 2 5 68 122 157 169 184 190 208 ...\n $ : int [1:51] 6 9 18 19 23 25 54 66 77 78 ...\n $ : int [1:35] 52 53 54 58 78 79 80 165 189 197 ...\n $ : int [1:37] 23 52 53 54 57 78 79 165 189 197 ...\n $ : int [1:5] 128 129 493 700 748\n $ : int [1:14] 21 61 158 269 310 311 561 563 578 589 ...\n $ : int [1:11] 21 60 162 268 269 484 578 589 592 596 ...\n $ : int [1:28] 15 22 32 49 51 82 177 196 207 214 ...\n $ : int [1:5] 384 416 467 765 772\n $ : int [1:7] 48 65 74 113 131 265 407\n $ : int [1:11] 48 64 74 109 113 265 386 407 683 701 ...\n $ : int [1:47] 1 2 5 9 10 18 19 25 56 103 ...\n $ : int [1:26] 72 120 124 179 182 304 305 339 346 347 ...\n $ : int [1:30] 1 2 11 26 27 43 55 122 157 190 ...\n $ : int [1:8] 140 146 248 274 473 500 512 513\n $ : int [1:44] 16 28 29 44 45 71 120 124 172 173 ...\n $ : int [1:50] 16 28 29 70 120 124 172 173 175 178 ...\n $ : int [1:19] 17 35 67 182 361 374 378 404 566 567 ...\n $ : int [1:6] 361 374 377 404 665 666\n $ : int [1:14] 48 64 65 109 113 116 251 265 672 683 ...\n $ : int [1:15] 110 229 255 258 272 373 382 398 422 433 ...\n $ : int [1:9] 254 287 427 459 470 547 647 677 751\n $ : int [1:55] 9 18 19 23 25 52 54 56 78 79 ...\n $ : int [1:51] 23 52 53 54 56 57 58 77 79 80 ...\n $ : int [1:57] 23 52 53 54 56 57 58 77 78 80 ...\n $ : int [1:39] 23 52 53 54 57 77 78 79 165 189 ...\n $ : int [1:19] 99 145 227 233 242 255 270 426 449 483 ...\n $ : int [1:21] 15 22 32 49 51 62 177 207 214 297 ...\n $ : int [1:6] 132 258 383 414 529 767\n $ : int [1:3] 148 437 692\n $ : int [1:38] 101 105 130 142 145 155 156 219 235 242 ...\n $ : int [1:17] 34 42 136 137 184 202 285 286 499 538 ...\n $ : int [1:19] 147 149 151 221 226 245 267 399 410 415 ...\n $ : int [1:5] 150 489 648 700 714\n $ : int [1:11] 100 107 159 260 408 463 542 674 676 681 ...\n $ : int 237\n $ : int [1:3] 160 271 406\n $ : int [1:11] 95 119 390 391 392 423 487 642 656 668 ...\n $ : int [1:3] 354 607 665\n $ : int [1:7] 13 31 158 436 561 596 709\n $ : int [1:10] 92 390 391 392 405 423 469 656 708 770\n $ : int [1:17] 97 108 139 167 168 350 389 403 412 420 ...\n $ : int [1:13] 96 108 114 139 147 168 389 403 420 451 ...\n $ : int [1:4] 153 231 432 696\n $ : int [1:18] 81 145 154 167 227 233 255 270 426 449 ...\n  [list output truncated]\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:774] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 72140, longlat = FALSE)\n - attr(*, \"dnn\")= num [1:2] 0 72140\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#plot-the-fixed-distance-neighbor-list",
    "href": "take_home_ex/ex_1/ex_1.html#plot-the-fixed-distance-neighbor-list",
    "title": "Take Home Ex-1",
    "section": "Plot the fixed distance neighbor list:",
    "text": "Plot the fixed distance neighbor list:\nUsing the plot() function, we will then visualize the neighbors that we have identified.\n\nplot(nga_wp_26391$geometry, border=\"black\", axes = TRUE)\nplot(nb_d72, coords, add=TRUE, col=\"red\")"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#create-row-standardized-weight-matrix",
    "href": "take_home_ex/ex_1/ex_1.html#create-row-standardized-weight-matrix",
    "title": "Take Home Ex-1",
    "section": "Create row standardized weight matrix",
    "text": "Create row standardized weight matrix\nWe will use the nb2listw() function of spdep package to convert the nb list to weights. We set the style to “W” in order to perform the row-standardized steps.\nWe run the code as follow:\n\nswm_d72<- nb2listw(nb_d72, style=\"W\", zero.policy = TRUE)"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#compute-spatial-lag-with-row-standardized-weights",
    "href": "take_home_ex/ex_1/ex_1.html#compute-spatial-lag-with-row-standardized-weights",
    "title": "Take Home Ex-1",
    "section": "Compute spatial lag with row-standardized weights",
    "text": "Compute spatial lag with row-standardized weights\nNow we will use the lag.listw() function from spdep to return us the lag list. As an input, we will provide the row-standardized weight matrix and the variables “wpt non-functional” & wpt functional.\n\nLag for non-functional\nWe run the code as follow:\n\nlag.list <- list(nga_wp_26391$shapeName, lag.listw(swm_d72, nga_wp_26391$`wpt non-functional`))\nlag.res_NF <- as.data.frame(lag.list)\ncolnames(lag.res_NF) <- c(\"shapeName\", \"lag_NF\")\nnga_wp_26391$lag_NF <- lag.res_NF$lag_NF\n\nWe will then plot the lagged variable:\n\nnon_func <- qtm(nga_wp_26391, \"wpt non-functional\") +\ntm_layout(main.title = \"WPT Non-Functional\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.position = c(\"right\", \"bottom\"),\n            legend.width = 0.3,\n            legend.height = 0.25,\n            frame = TRUE)\nlag_non_func <- qtm(nga_wp_26391, \"lag_NF\")+\ntm_layout(main.title = \"Lagged WPT Non-Functional\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.position = c(\"right\", \"bottom\"),\n            legend.width = 0.3,\n            legend.height = 0.25,\n            frame = TRUE)\ntmap_arrange(non_func, lag_non_func, asp=1, ncol=2)\n\n\n\n\n\n\nLag for functional\nWe run the code as follow:\n\nlag.list <- list(nga_wp_26391$shapeName, lag.listw(swm_d72, nga_wp_26391$`wpt functional`))\nlag.res_F <- as.data.frame(lag.list)\ncolnames(lag.res_F) <- c(\"shapeName\", \"lag_F\")\nnga_wp_26391$lag_F <- lag.res_F$lag_F\n\n\nnon_func <- qtm(nga_wp_26391, \"wpt functional\") +\ntm_layout(main.title = \"WPT Functional\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.position = c(\"right\", \"bottom\"),\n            legend.width = 0.3,\n            legend.height = 0.25,\n            frame = TRUE)\nlag_non_func <- qtm(nga_wp_26391, \"lag_F\")+\ntm_layout(main.title = \"Lagged WPT Functional\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.position = c(\"right\", \"bottom\"),\n            legend.width = 0.3,\n            legend.height = 0.25,\n            frame = TRUE)\ntmap_arrange(non_func, lag_non_func, asp=1, ncol=2)"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#global-morans-i",
    "href": "take_home_ex/ex_1/ex_1.html#global-morans-i",
    "title": "Take Home Ex-1",
    "section": "Global Moran’s I",
    "text": "Global Moran’s I\nTo get an indication of the global spatial clustering auto-correlation, we will perform the Moran’s I test. This is an analytic approach.\nWPT Non-Functional Moran’s I test:\n\nmoran.test(nga_wp_26391$`wpt non-functional`,\n           listw=swm_d72,\n           zero.policy = TRUE,\n           na.action=na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  nga_wp_26391$`wpt non-functional`  \nweights: swm_d72    \n\nMoran I statistic standard deviate = 22.437, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.3264059335     -0.0012936611      0.0002133094 \n\n\nThe global Moran’s I statistic is >> 0 and the p-value is statistically significant. This shows that there is indication of clustering of the non-functional water point.\n\nWPT Functional Moran’s I test:\n\nmoran.test(nga_wp_26391$`wpt functional`,\n           listw=swm_d72,\n           zero.policy = TRUE,\n           na.action=na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  nga_wp_26391$`wpt functional`  \nweights: swm_d72    \n\nMoran I statistic standard deviate = 34.908, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.5041687788     -0.0012936611      0.0002096643 \n\n\nThe global Moran’s I statistic is >> 0 and the p-value is statistically significant. This shows that there is indication of clustering of the functional water point."
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#monte-carlo-morans-i",
    "href": "take_home_ex/ex_1/ex_1.html#monte-carlo-morans-i",
    "title": "Take Home Ex-1",
    "section": "Monte Carlo Moran’s I",
    "text": "Monte Carlo Moran’s I\nWhile the Moran’s I test is fast since it works analytically, we will need to perform Monte Carlo Moran’s I. This method allows us to perform simulation by generating many random datasets across multiple simulations.\nOur Moran’s I should fall to either extremes of the Moran’s I histogram from the simulation. This shows that our Moran’s I value did not occur because of randomization.\nFor the Monte Carlo Moran’s I test, we will use the moran.mc() function from the spdep package.\nWPT Non-Functional Moran’s I test:\n\nset.seed(1234)\nbperm_NF= moran.mc(nga_wp_26391$`wpt non-functional`, \n                listw=swm_d72, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm_NF\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  nga_wp_26391$`wpt non-functional` \nweights: swm_d72  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.32641, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nHere we can see that our results are statistically significant with p value of 0.001. Also the Moran’s I calculated is similar to the analytic test.\nWe will visualize the simulation results from Monte Carlo as follow:\n\nhist(bperm_NF$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I for Non-Functional\")\nabline(v=0, \n       col=\"red\") \n\n\n\n\n\nWPT Functional Moran’s I test:\n\nset.seed(1234)\nbperm_F= moran.mc(nga_wp_26391$`wpt functional`, \n                listw=swm_d72, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm_F\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  nga_wp_26391$`wpt functional` \nweights: swm_d72  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.50417, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nHere we can see that our results are statistically significant with p value of 0.001. Also the Moran’s I calculated is similar to the analytic test.\nWe will visualize the simulation results from Monte Carlo as follow:\n\nhist(bperm_F$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I for Non-Functional\")\nabline(v=0, \n       col=\"red\")"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#non-functional-water-points-local-morans-i",
    "href": "take_home_ex/ex_1/ex_1.html#non-functional-water-points-local-morans-i",
    "title": "Take Home Ex-1",
    "section": "Non-Functional Water Points (Local Moran’s I)",
    "text": "Non-Functional Water Points (Local Moran’s I)\nWe will use the function order() to create an ordered name list of the areas. This is then followed by the function localmoran() from spdep. Our variable of interest and row-standardized weight matrix is required.\n\nlocalMI_NF <- localmoran(nga_wp_26391$`wpt non-functional`, swm_d72)\nhead(localMI_NF)\n\n            Ii          E.Ii       Var.Ii       Z.Ii Pr(z != E(Ii))\n1  0.361394136 -9.995243e-04 1.128237e-02  3.4117747   0.0006454144\n2  0.074414950 -4.092463e-05 4.705097e-04  3.4325327   0.0005979717\n3  1.258199847 -1.627684e-03 6.280738e-01  1.5896655   0.1119102304\n4 -0.006652507 -5.427505e-05 4.151689e-03 -0.1024036   0.9184363392\n5  0.082615173 -2.590965e-04 3.325093e-03  1.4372021   0.1506605779\n6  0.006672593 -1.538445e-07 5.523369e-06  2.8392431   0.0045220690\n\n\n\nlocalMI_NF <- data.frame(localMI_NF)\ncolnames(localMI_NF)[5] =\"Pr\"\nnga_wp_26391$lc_Ii_NF <- localMI_NF$'Ii'\nnga_wp_26391$lc_Pr_NF <- localMI_NF$'Pr'\n\n\nlocalMI.map_NF <- tm_shape(nga_wp_26391) +\n  tm_fill(col = \"lc_Ii_NF\", \n          style = \"jenks\", \n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Plot of Local Moran's I\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = TRUE)\n\npvalue.map_NF <- tm_shape(nga_wp_26391) +\n  tm_fill(col = \"lc_Pr_NF\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Plot of Local Moran's I P-Value\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = TRUE)\n\ntmap_arrange(localMI.map_NF, pvalue.map_NF, asp=1, ncol=2)\n\nVariable(s) \"lc_Ii_NF\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette."
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#functional-water-points-local-morans-i",
    "href": "take_home_ex/ex_1/ex_1.html#functional-water-points-local-morans-i",
    "title": "Take Home Ex-1",
    "section": "Functional Water Points (Local Moran’s I)",
    "text": "Functional Water Points (Local Moran’s I)\nWe perform the same steps for Functional water points:\n\nlocalMI_F <- localmoran(nga_wp_26391$`wpt functional`, swm_d72)\nhead(localMI_F)\n\n          Ii          E.Ii      Var.Ii      Z.Ii Pr(z != E(Ii))\n1 0.43151603 -7.191834e-04 0.008120236 4.7966255   1.613609e-06\n2 0.27475350 -2.904635e-04 0.003338620 4.7601280   1.934703e-06\n3 0.69235062 -8.956670e-04 0.345864093 1.1787856   2.384836e-01\n4 0.05590525 -3.884365e-04 0.029702941 0.3266329   7.439455e-01\n5 0.33277612 -3.884365e-04 0.004984321 4.7190630   2.369335e-06\n6 0.05909213 -4.231402e-05 0.001519106 1.5172126   1.292130e-01\n\n\n\nlocalMI_F <- data.frame(localMI_F)\ncolnames(localMI_F)[5] =\"Pr\"\nnga_wp_26391$lc_Ii_F <- localMI_F$'Ii'\nnga_wp_26391$lc_Pr_F <- localMI_F$'Pr'\n\n\nlocalMI.map_F <- tm_shape(nga_wp_26391) +\n  tm_fill(col = \"lc_Ii_F\", \n          style = \"jenks\", \n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Plot of Local Moran's I\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = TRUE)\n\npvalue.map_F <- tm_shape(nga_wp_26391) +\n  tm_fill(col = \"lc_Pr_F\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Plot of Local Moran's I P-Value\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = TRUE)\n\ntmap_arrange(localMI.map_F, pvalue.map_F, asp=1, ncol=2)\n\nVariable(s) \"lc_Ii_F\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette."
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#scatterplot-for-non-functional-water-points",
    "href": "take_home_ex/ex_1/ex_1.html#scatterplot-for-non-functional-water-points",
    "title": "Take Home Ex-1",
    "section": "Scatterplot for Non-Functional water points",
    "text": "Scatterplot for Non-Functional water points\n\nNF_scatter <- moran.plot(nga_wp_26391$`wpt non-functional`, swm_d72,\n                  labels=as.character(nga_wp_26391$shapeName), \n                  xlab=\"wpt non-functional\", \n                  ylab=\"Spatially lagged wpt non-functional\")"
  },
  {
    "objectID": "take_home_ex/ex_1/ex_1.html#scatterplot-for-functional-water-points",
    "href": "take_home_ex/ex_1/ex_1.html#scatterplot-for-functional-water-points",
    "title": "Take Home Ex-1",
    "section": "Scatterplot for Functional water points",
    "text": "Scatterplot for Functional water points\n\nF_scatter <- moran.plot(nga_wp_26391$`wpt functional`, swm_d72,\n                  labels=as.character(nga_wp_26391$shapeName), \n                  xlab=\"wpt functional\", \n                  ylab=\"Spatially lagged wpt functional\")"
  }
]